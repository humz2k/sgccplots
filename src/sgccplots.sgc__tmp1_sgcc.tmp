#define __generate(...) 
 #define bool _Bool 
 #define true ((_Bool)1) 
 #define false ((_Bool)0) 
# 0 "src/sgccplots.sgc"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "src/sgccplots.sgc"
# 1 "/Users/humzaqureshi/GitHub/sugaryc/include/stdlib.sgh" 1




# 1 "/Users/humzaqureshi/GitHub/sugaryc/include/../cstdlib/stdlib_macros.h" 1


typedef unsigned long size_t;
# 6 "/Users/humzaqureshi/GitHub/sugaryc/include/stdlib.sgh" 2

extern void* malloc(long unsigned int);

extern void free(void*);
# 18 "/Users/humzaqureshi/GitHub/sugaryc/include/stdlib.sgh"
# 1 "/Users/humzaqureshi/GitHub/sugaryc/include/print.sgh" 1



const char* __str__(const char* s);

const char* __str__(float f);
const char* __str__(double f);

const char* __str__(short a);

const char* __str__(int a);

const char* __str__(long int a);

const char* __str__(long long int a);
# 19 "/Users/humzaqureshi/GitHub/sugaryc/include/stdlib.sgh" 2

# 1 "/Users/humzaqureshi/GitHub/sugaryc/include/int_tuple.sgh" 1



struct _int_tuple;

typedef struct _int_tuple* int_tuple;

int_tuple make_int_tuple(int* raw, int length);

const int* __index__(int_tuple t, int* idx, int nidx);

int len(int_tuple t);

const char* __str__(int_tuple t);
# 21 "/Users/humzaqureshi/GitHub/sugaryc/include/stdlib.sgh" 2

# 1 "/Users/humzaqureshi/GitHub/sugaryc/include/vector_types.sgh" 1




# 1 "/Users/humzaqureshi/GitHub/sugaryc/include/vector_definition.sgh" 1




# 1 "/Users/humzaqureshi/GitHub/sugaryc/include/string.sgh" 1



typedef const char* string;

string __add__(string left, string right);

string __mul__(string left, int right);

string __mul__(int left, string right);

int __eq__(string left, string right);

int __neq__(string left, string right);

int len(string str);
# 6 "/Users/humzaqureshi/GitHub/sugaryc/include/vector_definition.sgh" 2
# 20 "/Users/humzaqureshi/GitHub/sugaryc/include/vector_definition.sgh"
typedef struct {
    float x;
    float y;
} float2;

static inline float2 make_float2(float x, float y){
    float2 out;
    out.x = x;
    out.y = y;
    return out;
}

static inline string __str__(float2 vec){
    string out = "float2" + "{" + to_str(vec.x) + ", " + to_str(vec.y) + "}";
    return out;
}

typedef struct {
    float x;
    float y;
    float z;
} float3;

static inline float3 make_float3(float x, float y, float z){
    float3 out;
    out.x = x;
    out.y = y;
    out.z = z;
    return out;
}

static inline string __str__(float3 vec){
    string out = "float3" + "{" + to_str(vec.x) + ", " + to_str(vec.y) + ", " + to_str(vec.z) + "}";
    return out;
}

typedef struct {
    float x;
    float y;
    float z;
    float w;
} float4;

static inline float4 make_float4(float x, float y, float z, float w){
    float4 out;
    out.x = x;
    out.y = y;
    out.z = z;
    out.w = w;
    return out;
}

static inline string __str__(float4 vec){
    string out = "float4" + "{" + to_str(vec.x) + ", " + to_str(vec.y) + ", " + to_str(vec.z) + ", " + to_str(vec.w) + "}";
    return out;
}
# 6 "/Users/humzaqureshi/GitHub/sugaryc/include/vector_types.sgh" 2



# 1 "/Users/humzaqureshi/GitHub/sugaryc/include/vector_definition.sgh" 1
# 20 "/Users/humzaqureshi/GitHub/sugaryc/include/vector_definition.sgh"
typedef struct {
    double x;
    double y;
} double2;

static inline double2 make_double2(double x, double y){
    double2 out;
    out.x = x;
    out.y = y;
    return out;
}

static inline string __str__(double2 vec){
    string out = "double2" + "{" + to_str(vec.x) + ", " + to_str(vec.y) + "}";
    return out;
}

typedef struct {
    double x;
    double y;
    double z;
} double3;

static inline double3 make_double3(double x, double y, double z){
    double3 out;
    out.x = x;
    out.y = y;
    out.z = z;
    return out;
}

static inline string __str__(double3 vec){
    string out = "double3" + "{" + to_str(vec.x) + ", " + to_str(vec.y) + ", " + to_str(vec.z) + "}";
    return out;
}

typedef struct {
    double x;
    double y;
    double z;
    double w;
} double4;

static inline double4 make_double4(double x, double y, double z, double w){
    double4 out;
    out.x = x;
    out.y = y;
    out.z = z;
    out.w = w;
    return out;
}

static inline string __str__(double4 vec){
    string out = "double4" + "{" + to_str(vec.x) + ", " + to_str(vec.y) + ", " + to_str(vec.z) + ", " + to_str(vec.w) + "}";
    return out;
}
# 10 "/Users/humzaqureshi/GitHub/sugaryc/include/vector_types.sgh" 2



# 1 "/Users/humzaqureshi/GitHub/sugaryc/include/vector_definition.sgh" 1
# 20 "/Users/humzaqureshi/GitHub/sugaryc/include/vector_definition.sgh"
typedef struct {
    short x;
    short y;
} short2;

static inline short2 make_short2(short x, short y){
    short2 out;
    out.x = x;
    out.y = y;
    return out;
}

static inline string __str__(short2 vec){
    string out = "short2" + "{" + to_str(vec.x) + ", " + to_str(vec.y) + "}";
    return out;
}

typedef struct {
    short x;
    short y;
    short z;
} short3;

static inline short3 make_short3(short x, short y, short z){
    short3 out;
    out.x = x;
    out.y = y;
    out.z = z;
    return out;
}

static inline string __str__(short3 vec){
    string out = "short3" + "{" + to_str(vec.x) + ", " + to_str(vec.y) + ", " + to_str(vec.z) + "}";
    return out;
}

typedef struct {
    short x;
    short y;
    short z;
    short w;
} short4;

static inline short4 make_short4(short x, short y, short z, short w){
    short4 out;
    out.x = x;
    out.y = y;
    out.z = z;
    out.w = w;
    return out;
}

static inline string __str__(short4 vec){
    string out = "short4" + "{" + to_str(vec.x) + ", " + to_str(vec.y) + ", " + to_str(vec.z) + ", " + to_str(vec.w) + "}";
    return out;
}
# 14 "/Users/humzaqureshi/GitHub/sugaryc/include/vector_types.sgh" 2



# 1 "/Users/humzaqureshi/GitHub/sugaryc/include/vector_definition.sgh" 1
# 20 "/Users/humzaqureshi/GitHub/sugaryc/include/vector_definition.sgh"
typedef struct {
    int x;
    int y;
} int2;

static inline int2 make_int2(int x, int y){
    int2 out;
    out.x = x;
    out.y = y;
    return out;
}

static inline string __str__(int2 vec){
    string out = "int2" + "{" + to_str(vec.x) + ", " + to_str(vec.y) + "}";
    return out;
}

typedef struct {
    int x;
    int y;
    int z;
} int3;

static inline int3 make_int3(int x, int y, int z){
    int3 out;
    out.x = x;
    out.y = y;
    out.z = z;
    return out;
}

static inline string __str__(int3 vec){
    string out = "int3" + "{" + to_str(vec.x) + ", " + to_str(vec.y) + ", " + to_str(vec.z) + "}";
    return out;
}

typedef struct {
    int x;
    int y;
    int z;
    int w;
} int4;

static inline int4 make_int4(int x, int y, int z, int w){
    int4 out;
    out.x = x;
    out.y = y;
    out.z = z;
    out.w = w;
    return out;
}

static inline string __str__(int4 vec){
    string out = "int4" + "{" + to_str(vec.x) + ", " + to_str(vec.y) + ", " + to_str(vec.z) + ", " + to_str(vec.w) + "}";
    return out;
}
# 18 "/Users/humzaqureshi/GitHub/sugaryc/include/vector_types.sgh" 2



# 1 "/Users/humzaqureshi/GitHub/sugaryc/include/vector_definition.sgh" 1
# 20 "/Users/humzaqureshi/GitHub/sugaryc/include/vector_definition.sgh"
typedef struct {
    long x;
    long y;
} long2;

static inline long2 make_long2(long x, long y){
    long2 out;
    out.x = x;
    out.y = y;
    return out;
}

static inline string __str__(long2 vec){
    string out = "long2" + "{" + to_str(vec.x) + ", " + to_str(vec.y) + "}";
    return out;
}

typedef struct {
    long x;
    long y;
    long z;
} long3;

static inline long3 make_long3(long x, long y, long z){
    long3 out;
    out.x = x;
    out.y = y;
    out.z = z;
    return out;
}

static inline string __str__(long3 vec){
    string out = "long3" + "{" + to_str(vec.x) + ", " + to_str(vec.y) + ", " + to_str(vec.z) + "}";
    return out;
}

typedef struct {
    long x;
    long y;
    long z;
    long w;
} long4;

static inline long4 make_long4(long x, long y, long z, long w){
    long4 out;
    out.x = x;
    out.y = y;
    out.z = z;
    out.w = w;
    return out;
}

static inline string __str__(long4 vec){
    string out = "long4" + "{" + to_str(vec.x) + ", " + to_str(vec.y) + ", " + to_str(vec.z) + ", " + to_str(vec.w) + "}";
    return out;
}
# 22 "/Users/humzaqureshi/GitHub/sugaryc/include/vector_types.sgh" 2
# 23 "/Users/humzaqureshi/GitHub/sugaryc/include/stdlib.sgh" 2
# 2 "src/sgccplots.sgc" 2
# 1 "src/../include/raylib.sgh" 1
# 203 "src/../include/raylib.sgh"
# 1 "/opt/homebrew/Cellar/gcc/13.2.0/lib/gcc/current/gcc/aarch64-apple-darwin21/13/include/stdbool.h" 1 3 4
# 204 "src/../include/raylib.sgh" 2






typedef struct Vector2 {
    float x;
    float y;
} Vector2;


typedef struct Vector3 {
    float x;
    float y;
    float z;
} Vector3;


typedef struct Vector4 {
    float x;
    float y;
    float z;
    float w;
} Vector4;


typedef Vector4 Quaternion;


typedef struct Matrix {
    float m0, m4, m8, m12;
    float m1, m5, m9, m13;
    float m2, m6, m10, m14;
    float m3, m7, m11, m15;
} Matrix;


typedef struct Color {
    unsigned char r;
    unsigned char g;
    unsigned char b;
    unsigned char a;
} Color;


typedef struct Rectangle {
    float x;
    float y;
    float width;
    float height;
} Rectangle;


typedef struct Image {
    void *data;
    int width;
    int height;
    int mipmaps;
    int format;
} Image;


typedef struct Texture {
    unsigned int id;
    int width;
    int height;
    int mipmaps;
    int format;
} Texture;


typedef Texture Texture2D;


typedef Texture TextureCubemap;


typedef struct RenderTexture {
    unsigned int id;
    Texture texture;
    Texture depth;
} RenderTexture;


typedef RenderTexture RenderTexture2D;


typedef struct NPatchInfo {
    Rectangle source;
    int left;
    int top;
    int right;
    int bottom;
    int layout;
} NPatchInfo;


typedef struct GlyphInfo {
    int value;
    int offsetX;
    int offsetY;
    int advanceX;
    Image image;
} GlyphInfo;


typedef struct Font {
    int baseSize;
    int glyphCount;
    int glyphPadding;
    Texture2D texture;
    Rectangle *recs;
    GlyphInfo *glyphs;
} Font;


typedef struct Camera3D {
    Vector3 position;
    Vector3 target;
    Vector3 up;
    float fovy;
    int projection;
} Camera3D;

typedef Camera3D Camera;


typedef struct Camera2D {
    Vector2 offset;
    Vector2 target;
    float rotation;
    float zoom;
} Camera2D;


typedef struct Mesh {
    int vertexCount;
    int triangleCount;


    float *vertices;
    float *texcoords;
    float *texcoords2;
    float *normals;
    float *tangents;
    unsigned char *colors;
    unsigned short *indices;


    float *animVertices;
    float *animNormals;
    unsigned char *boneIds;
    float *boneWeights;


    unsigned int vaoId;
    unsigned int *vboId;
} Mesh;


typedef struct Shader {
    unsigned int id;
    int *locs;
} Shader;


typedef struct MaterialMap {
    Texture2D texture;
    Color color;
    float value;
} MaterialMap;


typedef struct Material {
    Shader shader;
    MaterialMap *maps;
    float params[4];
} Material;


typedef struct Transform {
    Vector3 translation;
    Quaternion rotation;
    Vector3 scale;
} Transform;


typedef struct BoneInfo {
    char name[32];
    int parent;
} BoneInfo;


typedef struct Model {
    Matrix transform;

    int meshCount;
    int materialCount;
    Mesh *meshes;
    Material *materials;
    int *meshMaterial;


    int boneCount;
    BoneInfo *bones;
    Transform *bindPose;
} Model;


typedef struct ModelAnimation {
    int boneCount;
    int frameCount;
    BoneInfo *bones;
    Transform **framePoses;
    char name[32];
} ModelAnimation;


typedef struct Ray {
    Vector3 position;
    Vector3 direction;
} Ray;


typedef struct RayCollision {
    
# 430 "src/../include/raylib.sgh" 3 4
   _Bool 
# 430 "src/../include/raylib.sgh"
        hit;
    float distance;
    Vector3 point;
    Vector3 normal;
} RayCollision;


typedef struct BoundingBox {
    Vector3 min;
    Vector3 max;
} BoundingBox;


typedef struct Wave {
    unsigned int frameCount;
    unsigned int sampleRate;
    unsigned int sampleSize;
    unsigned int channels;
    void *data;
} Wave;



typedef struct rAudioBuffer rAudioBuffer;
typedef struct rAudioProcessor rAudioProcessor;


typedef struct AudioStream {
    rAudioBuffer *buffer;
    rAudioProcessor *processor;

    unsigned int sampleRate;
    unsigned int sampleSize;
    unsigned int channels;
} AudioStream;


typedef struct Sound {
    AudioStream stream;
    unsigned int frameCount;
} Sound;


typedef struct Music {
    AudioStream stream;
    unsigned int frameCount;
    
# 476 "src/../include/raylib.sgh" 3 4
   _Bool 
# 476 "src/../include/raylib.sgh"
        looping;

    int ctxType;
    void *ctxData;
} Music;


typedef struct VrDeviceInfo {
    int hResolution;
    int vResolution;
    float hScreenSize;
    float vScreenSize;
    float eyeToScreenDistance;
    float lensSeparationDistance;
    float interpupillaryDistance;
    float lensDistortionValues[4];
    float chromaAbCorrection[4];
} VrDeviceInfo;


typedef struct VrStereoConfig {
    Matrix projection[2];
    Matrix viewOffset[2];
    float leftLensCenter[2];
    float rightLensCenter[2];
    float leftScreenCenter[2];
    float rightScreenCenter[2];
    float scale[2];
    float scaleIn[2];
} VrStereoConfig;


typedef struct FilePathList {
    unsigned int capacity;
    unsigned int count;
    char **paths;
} FilePathList;


typedef struct AutomationEvent {
    unsigned int frame;
    unsigned int type;
    int params[4];
} AutomationEvent;


typedef struct AutomationEventList {
    unsigned int capacity;
    unsigned int count;
    AutomationEvent *events;
} AutomationEventList;







typedef enum {
    FLAG_VSYNC_HINT = 0x00000040,
    FLAG_FULLSCREEN_MODE = 0x00000002,
    FLAG_WINDOW_RESIZABLE = 0x00000004,
    FLAG_WINDOW_UNDECORATED = 0x00000008,
    FLAG_WINDOW_HIDDEN = 0x00000080,
    FLAG_WINDOW_MINIMIZED = 0x00000200,
    FLAG_WINDOW_MAXIMIZED = 0x00000400,
    FLAG_WINDOW_UNFOCUSED = 0x00000800,
    FLAG_WINDOW_TOPMOST = 0x00001000,
    FLAG_WINDOW_ALWAYS_RUN = 0x00000100,
    FLAG_WINDOW_TRANSPARENT = 0x00000010,
    FLAG_WINDOW_HIGHDPI = 0x00002000,
    FLAG_WINDOW_MOUSE_PASSTHROUGH = 0x00004000,
    FLAG_BORDERLESS_WINDOWED_MODE = 0x00008000,
    FLAG_MSAA_4X_HINT = 0x00000020,
    FLAG_INTERLACED_HINT = 0x00010000
} ConfigFlags;



typedef enum {
    LOG_ALL = 0,
    LOG_TRACE,
    LOG_DEBUG,
    LOG_INFO,
    LOG_WARNING,
    LOG_ERROR,
    LOG_FATAL,
    LOG_NONE
} TraceLogLevel;




typedef enum {
    KEY_NULL = 0,

    KEY_APOSTROPHE = 39,
    KEY_COMMA = 44,
    KEY_MINUS = 45,
    KEY_PERIOD = 46,
    KEY_SLASH = 47,
    KEY_ZERO = 48,
    KEY_ONE = 49,
    KEY_TWO = 50,
    KEY_THREE = 51,
    KEY_FOUR = 52,
    KEY_FIVE = 53,
    KEY_SIX = 54,
    KEY_SEVEN = 55,
    KEY_EIGHT = 56,
    KEY_NINE = 57,
    KEY_SEMICOLON = 59,
    KEY_EQUAL = 61,
    KEY_A = 65,
    KEY_B = 66,
    KEY_C = 67,
    KEY_D = 68,
    KEY_E = 69,
    KEY_F = 70,
    KEY_G = 71,
    KEY_H = 72,
    KEY_I = 73,
    KEY_J = 74,
    KEY_K = 75,
    KEY_L = 76,
    KEY_M = 77,
    KEY_N = 78,
    KEY_O = 79,
    KEY_P = 80,
    KEY_Q = 81,
    KEY_R = 82,
    KEY_S = 83,
    KEY_T = 84,
    KEY_U = 85,
    KEY_V = 86,
    KEY_W = 87,
    KEY_X = 88,
    KEY_Y = 89,
    KEY_Z = 90,
    KEY_LEFT_BRACKET = 91,
    KEY_BACKSLASH = 92,
    KEY_RIGHT_BRACKET = 93,
    KEY_GRAVE = 96,

    KEY_SPACE = 32,
    KEY_ESCAPE = 256,
    KEY_ENTER = 257,
    KEY_TAB = 258,
    KEY_BACKSPACE = 259,
    KEY_INSERT = 260,
    KEY_DELETE = 261,
    KEY_RIGHT = 262,
    KEY_LEFT = 263,
    KEY_DOWN = 264,
    KEY_UP = 265,
    KEY_PAGE_UP = 266,
    KEY_PAGE_DOWN = 267,
    KEY_HOME = 268,
    KEY_END = 269,
    KEY_CAPS_LOCK = 280,
    KEY_SCROLL_LOCK = 281,
    KEY_NUM_LOCK = 282,
    KEY_PRINT_SCREEN = 283,
    KEY_PAUSE = 284,
    KEY_F1 = 290,
    KEY_F2 = 291,
    KEY_F3 = 292,
    KEY_F4 = 293,
    KEY_F5 = 294,
    KEY_F6 = 295,
    KEY_F7 = 296,
    KEY_F8 = 297,
    KEY_F9 = 298,
    KEY_F10 = 299,
    KEY_F11 = 300,
    KEY_F12 = 301,
    KEY_LEFT_SHIFT = 340,
    KEY_LEFT_CONTROL = 341,
    KEY_LEFT_ALT = 342,
    KEY_LEFT_SUPER = 343,
    KEY_RIGHT_SHIFT = 344,
    KEY_RIGHT_CONTROL = 345,
    KEY_RIGHT_ALT = 346,
    KEY_RIGHT_SUPER = 347,
    KEY_KB_MENU = 348,

    KEY_KP_0 = 320,
    KEY_KP_1 = 321,
    KEY_KP_2 = 322,
    KEY_KP_3 = 323,
    KEY_KP_4 = 324,
    KEY_KP_5 = 325,
    KEY_KP_6 = 326,
    KEY_KP_7 = 327,
    KEY_KP_8 = 328,
    KEY_KP_9 = 329,
    KEY_KP_DECIMAL = 330,
    KEY_KP_DIVIDE = 331,
    KEY_KP_MULTIPLY = 332,
    KEY_KP_SUBTRACT = 333,
    KEY_KP_ADD = 334,
    KEY_KP_ENTER = 335,
    KEY_KP_EQUAL = 336,

    KEY_BACK = 4,
    KEY_MENU = 5,
    KEY_VOLUME_UP = 24,
    KEY_VOLUME_DOWN = 25
} KeyboardKey;







typedef enum {
    MOUSE_BUTTON_LEFT = 0,
    MOUSE_BUTTON_RIGHT = 1,
    MOUSE_BUTTON_MIDDLE = 2,
    MOUSE_BUTTON_SIDE = 3,
    MOUSE_BUTTON_EXTRA = 4,
    MOUSE_BUTTON_FORWARD = 5,
    MOUSE_BUTTON_BACK = 6,
} MouseButton;


typedef enum {
    MOUSE_CURSOR_DEFAULT = 0,
    MOUSE_CURSOR_ARROW = 1,
    MOUSE_CURSOR_IBEAM = 2,
    MOUSE_CURSOR_CROSSHAIR = 3,
    MOUSE_CURSOR_POINTING_HAND = 4,
    MOUSE_CURSOR_RESIZE_EW = 5,
    MOUSE_CURSOR_RESIZE_NS = 6,
    MOUSE_CURSOR_RESIZE_NWSE = 7,
    MOUSE_CURSOR_RESIZE_NESW = 8,
    MOUSE_CURSOR_RESIZE_ALL = 9,
    MOUSE_CURSOR_NOT_ALLOWED = 10
} MouseCursor;


typedef enum {
    GAMEPAD_BUTTON_UNKNOWN = 0,
    GAMEPAD_BUTTON_LEFT_FACE_UP,
    GAMEPAD_BUTTON_LEFT_FACE_RIGHT,
    GAMEPAD_BUTTON_LEFT_FACE_DOWN,
    GAMEPAD_BUTTON_LEFT_FACE_LEFT,
    GAMEPAD_BUTTON_RIGHT_FACE_UP,
    GAMEPAD_BUTTON_RIGHT_FACE_RIGHT,
    GAMEPAD_BUTTON_RIGHT_FACE_DOWN,
    GAMEPAD_BUTTON_RIGHT_FACE_LEFT,
    GAMEPAD_BUTTON_LEFT_TRIGGER_1,
    GAMEPAD_BUTTON_LEFT_TRIGGER_2,
    GAMEPAD_BUTTON_RIGHT_TRIGGER_1,
    GAMEPAD_BUTTON_RIGHT_TRIGGER_2,
    GAMEPAD_BUTTON_MIDDLE_LEFT,
    GAMEPAD_BUTTON_MIDDLE,
    GAMEPAD_BUTTON_MIDDLE_RIGHT,
    GAMEPAD_BUTTON_LEFT_THUMB,
    GAMEPAD_BUTTON_RIGHT_THUMB
} GamepadButton;


typedef enum {
    GAMEPAD_AXIS_LEFT_X = 0,
    GAMEPAD_AXIS_LEFT_Y = 1,
    GAMEPAD_AXIS_RIGHT_X = 2,
    GAMEPAD_AXIS_RIGHT_Y = 3,
    GAMEPAD_AXIS_LEFT_TRIGGER = 4,
    GAMEPAD_AXIS_RIGHT_TRIGGER = 5
} GamepadAxis;


typedef enum {
    MATERIAL_MAP_ALBEDO = 0,
    MATERIAL_MAP_METALNESS,
    MATERIAL_MAP_NORMAL,
    MATERIAL_MAP_ROUGHNESS,
    MATERIAL_MAP_OCCLUSION,
    MATERIAL_MAP_EMISSION,
    MATERIAL_MAP_HEIGHT,
    MATERIAL_MAP_CUBEMAP,
    MATERIAL_MAP_IRRADIANCE,
    MATERIAL_MAP_PREFILTER,
    MATERIAL_MAP_BRDF
} MaterialMapIndex;





typedef enum {
    SHADER_LOC_VERTEX_POSITION = 0,
    SHADER_LOC_VERTEX_TEXCOORD01,
    SHADER_LOC_VERTEX_TEXCOORD02,
    SHADER_LOC_VERTEX_NORMAL,
    SHADER_LOC_VERTEX_TANGENT,
    SHADER_LOC_VERTEX_COLOR,
    SHADER_LOC_MATRIX_MVP,
    SHADER_LOC_MATRIX_VIEW,
    SHADER_LOC_MATRIX_PROJECTION,
    SHADER_LOC_MATRIX_MODEL,
    SHADER_LOC_MATRIX_NORMAL,
    SHADER_LOC_VECTOR_VIEW,
    SHADER_LOC_COLOR_DIFFUSE,
    SHADER_LOC_COLOR_SPECULAR,
    SHADER_LOC_COLOR_AMBIENT,
    SHADER_LOC_MAP_ALBEDO,
    SHADER_LOC_MAP_METALNESS,
    SHADER_LOC_MAP_NORMAL,
    SHADER_LOC_MAP_ROUGHNESS,
    SHADER_LOC_MAP_OCCLUSION,
    SHADER_LOC_MAP_EMISSION,
    SHADER_LOC_MAP_HEIGHT,
    SHADER_LOC_MAP_CUBEMAP,
    SHADER_LOC_MAP_IRRADIANCE,
    SHADER_LOC_MAP_PREFILTER,
    SHADER_LOC_MAP_BRDF
} ShaderLocationIndex;





typedef enum {
    SHADER_UNIFORM_FLOAT = 0,
    SHADER_UNIFORM_VEC2,
    SHADER_UNIFORM_VEC3,
    SHADER_UNIFORM_VEC4,
    SHADER_UNIFORM_INT,
    SHADER_UNIFORM_IVEC2,
    SHADER_UNIFORM_IVEC3,
    SHADER_UNIFORM_IVEC4,
    SHADER_UNIFORM_SAMPLER2D
} ShaderUniformDataType;


typedef enum {
    SHADER_ATTRIB_FLOAT = 0,
    SHADER_ATTRIB_VEC2,
    SHADER_ATTRIB_VEC3,
    SHADER_ATTRIB_VEC4
} ShaderAttributeDataType;



typedef enum {
    PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1,
    PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA,
    PIXELFORMAT_UNCOMPRESSED_R5G6B5,
    PIXELFORMAT_UNCOMPRESSED_R8G8B8,
    PIXELFORMAT_UNCOMPRESSED_R5G5B5A1,
    PIXELFORMAT_UNCOMPRESSED_R4G4B4A4,
    PIXELFORMAT_UNCOMPRESSED_R8G8B8A8,
    PIXELFORMAT_UNCOMPRESSED_R32,
    PIXELFORMAT_UNCOMPRESSED_R32G32B32,
    PIXELFORMAT_UNCOMPRESSED_R32G32B32A32,
    PIXELFORMAT_UNCOMPRESSED_R16,
    PIXELFORMAT_UNCOMPRESSED_R16G16B16,
    PIXELFORMAT_UNCOMPRESSED_R16G16B16A16,
    PIXELFORMAT_COMPRESSED_DXT1_RGB,
    PIXELFORMAT_COMPRESSED_DXT1_RGBA,
    PIXELFORMAT_COMPRESSED_DXT3_RGBA,
    PIXELFORMAT_COMPRESSED_DXT5_RGBA,
    PIXELFORMAT_COMPRESSED_ETC1_RGB,
    PIXELFORMAT_COMPRESSED_ETC2_RGB,
    PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA,
    PIXELFORMAT_COMPRESSED_PVRT_RGB,
    PIXELFORMAT_COMPRESSED_PVRT_RGBA,
    PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA,
    PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA
} PixelFormat;




typedef enum {
    TEXTURE_FILTER_POINT = 0,
    TEXTURE_FILTER_BILINEAR,
    TEXTURE_FILTER_TRILINEAR,
    TEXTURE_FILTER_ANISOTROPIC_4X,
    TEXTURE_FILTER_ANISOTROPIC_8X,
    TEXTURE_FILTER_ANISOTROPIC_16X,
} TextureFilter;


typedef enum {
    TEXTURE_WRAP_REPEAT = 0,
    TEXTURE_WRAP_CLAMP,
    TEXTURE_WRAP_MIRROR_REPEAT,
    TEXTURE_WRAP_MIRROR_CLAMP
} TextureWrap;


typedef enum {
    CUBEMAP_LAYOUT_AUTO_DETECT = 0,
    CUBEMAP_LAYOUT_LINE_VERTICAL,
    CUBEMAP_LAYOUT_LINE_HORIZONTAL,
    CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR,
    CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE,
    CUBEMAP_LAYOUT_PANORAMA
} CubemapLayout;


typedef enum {
    FONT_DEFAULT = 0,
    FONT_BITMAP,
    FONT_SDF
} FontType;


typedef enum {
    BLEND_ALPHA = 0,
    BLEND_ADDITIVE,
    BLEND_MULTIPLIED,
    BLEND_ADD_COLORS,
    BLEND_SUBTRACT_COLORS,
    BLEND_ALPHA_PREMULTIPLY,
    BLEND_CUSTOM,
    BLEND_CUSTOM_SEPARATE
} BlendMode;



typedef enum {
    GESTURE_NONE = 0,
    GESTURE_TAP = 1,
    GESTURE_DOUBLETAP = 2,
    GESTURE_HOLD = 4,
    GESTURE_DRAG = 8,
    GESTURE_SWIPE_RIGHT = 16,
    GESTURE_SWIPE_LEFT = 32,
    GESTURE_SWIPE_UP = 64,
    GESTURE_SWIPE_DOWN = 128,
    GESTURE_PINCH_IN = 256,
    GESTURE_PINCH_OUT = 512
} Gesture;


typedef enum {
    CAMERA_CUSTOM = 0,
    CAMERA_FREE,
    CAMERA_ORBITAL,
    CAMERA_FIRST_PERSON,
    CAMERA_THIRD_PERSON
} CameraMode;


typedef enum {
    CAMERA_PERSPECTIVE = 0,
    CAMERA_ORTHOGRAPHIC
} CameraProjection;


typedef enum {
    NPATCH_NINE_PATCH = 0,
    NPATCH_THREE_PATCH_VERTICAL,
    NPATCH_THREE_PATCH_HORIZONTAL
} NPatchLayout;




typedef unsigned char *(*LoadFileDataCallback)(const char *fileName, int *dataSize);
typedef 
# 941 "src/../include/raylib.sgh" 3 4
       _Bool 
# 941 "src/../include/raylib.sgh"
            (*SaveFileDataCallback)(const char *fileName, void *data, int dataSize);
typedef char *(*LoadFileTextCallback)(const char *fileName);
typedef 
# 943 "src/../include/raylib.sgh" 3 4
       _Bool 
# 943 "src/../include/raylib.sgh"
            (*SaveFileTextCallback)(const char *fileName, char *text);
# 959 "src/../include/raylib.sgh"
extern void InitWindow(int width, int height, const char *title);
extern void CloseWindow(void);
extern 
# 961 "src/../include/raylib.sgh" 3 4
     _Bool 
# 961 "src/../include/raylib.sgh"
          WindowShouldClose(void);
extern 
# 962 "src/../include/raylib.sgh" 3 4
     _Bool 
# 962 "src/../include/raylib.sgh"
          IsWindowReady(void);
extern 
# 963 "src/../include/raylib.sgh" 3 4
     _Bool 
# 963 "src/../include/raylib.sgh"
          IsWindowFullscreen(void);
extern 
# 964 "src/../include/raylib.sgh" 3 4
     _Bool 
# 964 "src/../include/raylib.sgh"
          IsWindowHidden(void);
extern 
# 965 "src/../include/raylib.sgh" 3 4
     _Bool 
# 965 "src/../include/raylib.sgh"
          IsWindowMinimized(void);
extern 
# 966 "src/../include/raylib.sgh" 3 4
     _Bool 
# 966 "src/../include/raylib.sgh"
          IsWindowMaximized(void);
extern 
# 967 "src/../include/raylib.sgh" 3 4
     _Bool 
# 967 "src/../include/raylib.sgh"
          IsWindowFocused(void);
extern 
# 968 "src/../include/raylib.sgh" 3 4
     _Bool 
# 968 "src/../include/raylib.sgh"
          IsWindowResized(void);
extern 
# 969 "src/../include/raylib.sgh" 3 4
     _Bool 
# 969 "src/../include/raylib.sgh"
          IsWindowState(unsigned int flag);
extern void SetWindowState(unsigned int flags);
extern void ClearWindowState(unsigned int flags);
extern void ToggleFullscreen(void);
extern void ToggleBorderlessWindowed(void);
extern void MaximizeWindow(void);
extern void MinimizeWindow(void);
extern void RestoreWindow(void);
extern void SetWindowIcon(Image image);
extern void SetWindowIcons(Image *images, int count);
extern void SetWindowTitle(const char *title);
extern void SetWindowPosition(int x, int y);
extern void SetWindowMonitor(int monitor);
extern void SetWindowMinSize(int width, int height);
extern void SetWindowMaxSize(int width, int height);
extern void SetWindowSize(int width, int height);
extern void SetWindowOpacity(float opacity);
extern void SetWindowFocused(void);
extern void *GetWindowHandle(void);
extern int GetScreenWidth(void);
extern int GetScreenHeight(void);
extern int GetRenderWidth(void);
extern int GetRenderHeight(void);
extern int GetMonitorCount(void);
extern int GetCurrentMonitor(void);
extern Vector2 GetMonitorPosition(int monitor);
extern int GetMonitorWidth(int monitor);
extern int GetMonitorHeight(int monitor);
extern int GetMonitorPhysicalWidth(int monitor);
extern int GetMonitorPhysicalHeight(int monitor);
extern int GetMonitorRefreshRate(int monitor);
extern Vector2 GetWindowPosition(void);
extern Vector2 GetWindowScaleDPI(void);
extern const char *GetMonitorName(int monitor);
extern void SetClipboardText(const char *text);
extern const char *GetClipboardText(void);
extern void EnableEventWaiting(void);
extern void DisableEventWaiting(void);


extern void ShowCursor(void);
extern void HideCursor(void);
extern 
# 1011 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1011 "src/../include/raylib.sgh"
          IsCursorHidden(void);
extern void EnableCursor(void);
extern void DisableCursor(void);
extern 
# 1014 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1014 "src/../include/raylib.sgh"
          IsCursorOnScreen(void);


extern void ClearBackground(Color color);
extern void BeginDrawing(void);
extern void EndDrawing(void);
extern void BeginMode2D(Camera2D camera);
extern void EndMode2D(void);
extern void BeginMode3D(Camera3D camera);
extern void EndMode3D(void);
extern void BeginTextureMode(RenderTexture2D target);
extern void EndTextureMode(void);
extern void BeginShaderMode(Shader shader);
extern void EndShaderMode(void);
extern void BeginBlendMode(int mode);
extern void EndBlendMode(void);
extern void BeginScissorMode(int x, int y, int width, int height);
extern void EndScissorMode(void);
extern void BeginVrStereoMode(VrStereoConfig config);
extern void EndVrStereoMode(void);


extern VrStereoConfig LoadVrStereoConfig(VrDeviceInfo device);
extern void UnloadVrStereoConfig(VrStereoConfig config);



extern Shader LoadShader(const char *vsFileName, const char *fsFileName);
extern Shader LoadShaderFromMemory(const char *vsCode, const char *fsCode);
extern 
# 1043 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1043 "src/../include/raylib.sgh"
          IsShaderReady(Shader shader);
extern int GetShaderLocation(Shader shader, const char *uniformName);
extern int GetShaderLocationAttrib(Shader shader, const char *attribName);
extern void SetShaderValue(Shader shader, int locIndex, const void *value, int uniformType);
extern void SetShaderValueV(Shader shader, int locIndex, const void *value, int uniformType, int count);
extern void SetShaderValueMatrix(Shader shader, int locIndex, Matrix mat);
extern void SetShaderValueTexture(Shader shader, int locIndex, Texture2D texture);
extern void UnloadShader(Shader shader);


extern Ray GetMouseRay(Vector2 mousePosition, Camera camera);
extern Matrix GetCameraMatrix(Camera camera);
extern Matrix GetCameraMatrix2D(Camera2D camera);
extern Vector2 GetWorldToScreen(Vector3 position, Camera camera);
extern Vector2 GetScreenToWorld2D(Vector2 position, Camera2D camera);
extern Vector2 GetWorldToScreenEx(Vector3 position, Camera camera, int width, int height);
extern Vector2 GetWorldToScreen2D(Vector2 position, Camera2D camera);


extern void SetTargetFPS(int fps);
extern float GetFrameTime(void);
extern double GetTime(void);
extern int GetFPS(void);





extern void SwapScreenBuffer(void);
extern void PollInputEvents(void);
extern void WaitTime(double seconds);


extern void SetRandomSeed(unsigned int seed);
extern int GetRandomValue(int min, int max);
extern int *LoadRandomSequence(unsigned int count, int min, int max);
extern void UnloadRandomSequence(int *sequence);


extern void TakeScreenshot(const char *fileName);
extern void SetConfigFlags(unsigned int flags);
extern void OpenURL(const char *url);



extern void TraceLog(int logLevel, const char *text, ...);
extern void SetTraceLogLevel(int logLevel);
extern void *MemAlloc(unsigned int size);
extern void *MemRealloc(void *ptr, unsigned int size);
extern void MemFree(void *ptr);
# 1103 "src/../include/raylib.sgh"
extern unsigned char *LoadFileData(const char *fileName, int *dataSize);
extern void UnloadFileData(unsigned char *data);
extern 
# 1105 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1105 "src/../include/raylib.sgh"
          SaveFileData(const char *fileName, void *data, int dataSize);
extern 
# 1106 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1106 "src/../include/raylib.sgh"
          ExportDataAsCode(const unsigned char *data, int dataSize, const char *fileName);
extern char *LoadFileText(const char *fileName);
extern void UnloadFileText(char *text);
extern 
# 1109 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1109 "src/../include/raylib.sgh"
          SaveFileText(const char *fileName, char *text);



extern 
# 1113 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1113 "src/../include/raylib.sgh"
          FileExists(const char *fileName);
extern 
# 1114 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1114 "src/../include/raylib.sgh"
          DirectoryExists(const char *dirPath);
extern 
# 1115 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1115 "src/../include/raylib.sgh"
          IsFileExtension(const char *fileName, const char *ext);
extern int GetFileLength(const char *fileName);
extern const char *GetFileExtension(const char *fileName);
extern const char *GetFileName(const char *filePath);
extern const char *GetFileNameWithoutExt(const char *filePath);
extern const char *GetDirectoryPath(const char *filePath);
extern const char *GetPrevDirectoryPath(const char *dirPath);
extern const char *GetWorkingDirectory(void);
extern const char *GetApplicationDirectory(void);
extern 
# 1124 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1124 "src/../include/raylib.sgh"
          ChangeDirectory(const char *dir);
extern 
# 1125 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1125 "src/../include/raylib.sgh"
          IsPathFile(const char *path);
extern FilePathList LoadDirectoryFiles(const char *dirPath);
extern FilePathList LoadDirectoryFilesEx(const char *basePath, const char *filter, 
# 1127 "src/../include/raylib.sgh" 3 4
                                                                                 _Bool 
# 1127 "src/../include/raylib.sgh"
                                                                                      scanSubdirs);
extern void UnloadDirectoryFiles(FilePathList files);
extern 
# 1129 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1129 "src/../include/raylib.sgh"
          IsFileDropped(void);
extern FilePathList LoadDroppedFiles(void);
extern void UnloadDroppedFiles(FilePathList files);
extern long GetFileModTime(const char *fileName);


extern unsigned char *CompressData(const unsigned char *data, int dataSize, int *compDataSize);
extern unsigned char *DecompressData(const unsigned char *compData, int compDataSize, int *dataSize);
extern char *EncodeDataBase64(const unsigned char *data, int dataSize, int *outputSize);
extern unsigned char *DecodeDataBase64(const unsigned char *data, int *outputSize);


extern AutomationEventList LoadAutomationEventList(const char *fileName);
extern void UnloadAutomationEventList(AutomationEventList list);
extern 
# 1143 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1143 "src/../include/raylib.sgh"
          ExportAutomationEventList(AutomationEventList list, const char *fileName);
extern void SetAutomationEventList(AutomationEventList *list);
extern void SetAutomationEventBaseFrame(int frame);
extern void StartAutomationEventRecording(void);
extern void StopAutomationEventRecording(void);
extern void PlayAutomationEvent(AutomationEvent event);






extern 
# 1155 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1155 "src/../include/raylib.sgh"
          IsKeyPressed(int key);
extern 
# 1156 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1156 "src/../include/raylib.sgh"
          IsKeyPressedRepeat(int key);
extern 
# 1157 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1157 "src/../include/raylib.sgh"
          IsKeyDown(int key);
extern 
# 1158 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1158 "src/../include/raylib.sgh"
          IsKeyReleased(int key);
extern 
# 1159 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1159 "src/../include/raylib.sgh"
          IsKeyUp(int key);
extern int GetKeyPressed(void);
extern int GetCharPressed(void);
extern void SetExitKey(int key);


extern 
# 1165 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1165 "src/../include/raylib.sgh"
          IsGamepadAvailable(int gamepad);
extern const char *GetGamepadName(int gamepad);
extern 
# 1167 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1167 "src/../include/raylib.sgh"
          IsGamepadButtonPressed(int gamepad, int button);
extern 
# 1168 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1168 "src/../include/raylib.sgh"
          IsGamepadButtonDown(int gamepad, int button);
extern 
# 1169 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1169 "src/../include/raylib.sgh"
          IsGamepadButtonReleased(int gamepad, int button);
extern 
# 1170 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1170 "src/../include/raylib.sgh"
          IsGamepadButtonUp(int gamepad, int button);
extern int GetGamepadButtonPressed(void);
extern int GetGamepadAxisCount(int gamepad);
extern float GetGamepadAxisMovement(int gamepad, int axis);
extern int SetGamepadMappings(const char *mappings);


extern 
# 1177 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1177 "src/../include/raylib.sgh"
          IsMouseButtonPressed(int button);
extern 
# 1178 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1178 "src/../include/raylib.sgh"
          IsMouseButtonDown(int button);
extern 
# 1179 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1179 "src/../include/raylib.sgh"
          IsMouseButtonReleased(int button);
extern 
# 1180 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1180 "src/../include/raylib.sgh"
          IsMouseButtonUp(int button);
extern int GetMouseX(void);
extern int GetMouseY(void);
extern Vector2 GetMousePosition(void);
extern Vector2 GetMouseDelta(void);
extern void SetMousePosition(int x, int y);
extern void SetMouseOffset(int offsetX, int offsetY);
extern void SetMouseScale(float scaleX, float scaleY);
extern float GetMouseWheelMove(void);
extern Vector2 GetMouseWheelMoveV(void);
extern void SetMouseCursor(int cursor);


extern int GetTouchX(void);
extern int GetTouchY(void);
extern Vector2 GetTouchPosition(int index);
extern int GetTouchPointId(int index);
extern int GetTouchPointCount(void);




extern void SetGesturesEnabled(unsigned int flags);
extern 
# 1203 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1203 "src/../include/raylib.sgh"
          IsGestureDetected(unsigned int gesture);
extern int GetGestureDetected(void);
extern float GetGestureHoldDuration(void);
extern Vector2 GetGestureDragVector(void);
extern float GetGestureDragAngle(void);
extern Vector2 GetGesturePinchVector(void);
extern float GetGesturePinchAngle(void);




extern void UpdateCamera(Camera *camera, int mode);
extern void UpdateCameraPro(Camera *camera, Vector3 movement, Vector3 rotation, float zoom);







extern void SetShapesTexture(Texture2D texture, Rectangle source);
extern Texture2D GetShapesTexture(void);
extern Rectangle GetShapesTextureRectangle(void);


extern void DrawPixel(int posX, int posY, Color color);
extern void DrawPixelV(Vector2 position, Color color);
extern void DrawLine(int startPosX, int startPosY, int endPosX, int endPosY, Color color);
extern void DrawLineV(Vector2 startPos, Vector2 endPos, Color color);
extern void DrawLineEx(Vector2 startPos, Vector2 endPos, float thick, Color color);
extern void DrawLineStrip(Vector2 *points, int pointCount, Color color);
extern void DrawLineBezier(Vector2 startPos, Vector2 endPos, float thick, Color color);
extern void DrawCircle(int centerX, int centerY, float radius, Color color);
extern void DrawCircleSector(Vector2 center, float radius, float startAngle, float endAngle, int segments, Color color);
extern void DrawCircleSectorLines(Vector2 center, float radius, float startAngle, float endAngle, int segments, Color color);
extern void DrawCircleGradient(int centerX, int centerY, float radius, Color color1, Color color2);
extern void DrawCircleV(Vector2 center, float radius, Color color);
extern void DrawCircleLines(int centerX, int centerY, float radius, Color color);
extern void DrawCircleLinesV(Vector2 center, float radius, Color color);
extern void DrawEllipse(int centerX, int centerY, float radiusH, float radiusV, Color color);
extern void DrawEllipseLines(int centerX, int centerY, float radiusH, float radiusV, Color color);
extern void DrawRing(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, Color color);
extern void DrawRingLines(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, Color color);
extern void DrawRectangle(int posX, int posY, int width, int height, Color color);
extern void DrawRectangleV(Vector2 position, Vector2 size, Color color);
extern void DrawRectangleRec(Rectangle rec, Color color);
extern void DrawRectanglePro(Rectangle rec, Vector2 origin, float rotation, Color color);
extern void DrawRectangleGradientV(int posX, int posY, int width, int height, Color color1, Color color2);
extern void DrawRectangleGradientH(int posX, int posY, int width, int height, Color color1, Color color2);
extern void DrawRectangleGradientEx(Rectangle rec, Color col1, Color col2, Color col3, Color col4);
extern void DrawRectangleLines(int posX, int posY, int width, int height, Color color);
extern void DrawRectangleLinesEx(Rectangle rec, float lineThick, Color color);
extern void DrawRectangleRounded(Rectangle rec, float roundness, int segments, Color color);
extern void DrawRectangleRoundedLines(Rectangle rec, float roundness, int segments, float lineThick, Color color);
extern void DrawTriangle(Vector2 v1, Vector2 v2, Vector2 v3, Color color);
extern void DrawTriangleLines(Vector2 v1, Vector2 v2, Vector2 v3, Color color);
extern void DrawTriangleFan(Vector2 *points, int pointCount, Color color);
extern void DrawTriangleStrip(Vector2 *points, int pointCount, Color color);
extern void DrawPoly(Vector2 center, int sides, float radius, float rotation, Color color);
extern void DrawPolyLines(Vector2 center, int sides, float radius, float rotation, Color color);
extern void DrawPolyLinesEx(Vector2 center, int sides, float radius, float rotation, float lineThick, Color color);


extern void DrawSplineLinear(Vector2 *points, int pointCount, float thick, Color color);
extern void DrawSplineBasis(Vector2 *points, int pointCount, float thick, Color color);
extern void DrawSplineCatmullRom(Vector2 *points, int pointCount, float thick, Color color);
extern void DrawSplineBezierQuadratic(Vector2 *points, int pointCount, float thick, Color color);
extern void DrawSplineBezierCubic(Vector2 *points, int pointCount, float thick, Color color);
extern void DrawSplineSegmentLinear(Vector2 p1, Vector2 p2, float thick, Color color);
extern void DrawSplineSegmentBasis(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float thick, Color color);
extern void DrawSplineSegmentCatmullRom(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float thick, Color color);
extern void DrawSplineSegmentBezierQuadratic(Vector2 p1, Vector2 c2, Vector2 p3, float thick, Color color);
extern void DrawSplineSegmentBezierCubic(Vector2 p1, Vector2 c2, Vector2 c3, Vector2 p4, float thick, Color color);


extern Vector2 GetSplinePointLinear(Vector2 startPos, Vector2 endPos, float t);
extern Vector2 GetSplinePointBasis(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t);
extern Vector2 GetSplinePointCatmullRom(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t);
extern Vector2 GetSplinePointBezierQuad(Vector2 p1, Vector2 c2, Vector2 p3, float t);
extern Vector2 GetSplinePointBezierCubic(Vector2 p1, Vector2 c2, Vector2 c3, Vector2 p4, float t);


extern 
# 1285 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1285 "src/../include/raylib.sgh"
          CheckCollisionRecs(Rectangle rec1, Rectangle rec2);
extern 
# 1286 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1286 "src/../include/raylib.sgh"
          CheckCollisionCircles(Vector2 center1, float radius1, Vector2 center2, float radius2);
extern 
# 1287 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1287 "src/../include/raylib.sgh"
          CheckCollisionCircleRec(Vector2 center, float radius, Rectangle rec);
extern 
# 1288 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1288 "src/../include/raylib.sgh"
          CheckCollisionPointRec(Vector2 point, Rectangle rec);
extern 
# 1289 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1289 "src/../include/raylib.sgh"
          CheckCollisionPointCircle(Vector2 point, Vector2 center, float radius);
extern 
# 1290 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1290 "src/../include/raylib.sgh"
          CheckCollisionPointTriangle(Vector2 point, Vector2 p1, Vector2 p2, Vector2 p3);
extern 
# 1291 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1291 "src/../include/raylib.sgh"
          CheckCollisionPointPoly(Vector2 point, Vector2 *points, int pointCount);
extern 
# 1292 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1292 "src/../include/raylib.sgh"
          CheckCollisionLines(Vector2 startPos1, Vector2 endPos1, Vector2 startPos2, Vector2 endPos2, Vector2 *collisionPoint);
extern 
# 1293 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1293 "src/../include/raylib.sgh"
          CheckCollisionPointLine(Vector2 point, Vector2 p1, Vector2 p2, int threshold);
extern Rectangle GetCollisionRec(Rectangle rec1, Rectangle rec2);







extern Image LoadImage(const char *fileName);
extern Image LoadImageRaw(const char *fileName, int width, int height, int format, int headerSize);
extern Image LoadImageSvg(const char *fileNameOrString, int width, int height);
extern Image LoadImageAnim(const char *fileName, int *frames);
extern Image LoadImageAnimFromMemory(const char *fileType, const unsigned char *fileData, int dataSize, int *frames);
extern Image LoadImageFromMemory(const char *fileType, const unsigned char *fileData, int dataSize);
extern Image LoadImageFromTexture(Texture2D texture);
extern Image LoadImageFromScreen(void);
extern 
# 1310 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1310 "src/../include/raylib.sgh"
          IsImageReady(Image image);
extern void UnloadImage(Image image);
extern 
# 1312 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1312 "src/../include/raylib.sgh"
          ExportImage(Image image, const char *fileName);
extern unsigned char *ExportImageToMemory(Image image, const char *fileType, int *fileSize);
extern 
# 1314 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1314 "src/../include/raylib.sgh"
          ExportImageAsCode(Image image, const char *fileName);


extern Image GenImageColor(int width, int height, Color color);
extern Image GenImageGradientLinear(int width, int height, int direction, Color start, Color end);
extern Image GenImageGradientRadial(int width, int height, float density, Color inner, Color outer);
extern Image GenImageGradientSquare(int width, int height, float density, Color inner, Color outer);
extern Image GenImageChecked(int width, int height, int checksX, int checksY, Color col1, Color col2);
extern Image GenImageWhiteNoise(int width, int height, float factor);
extern Image GenImagePerlinNoise(int width, int height, int offsetX, int offsetY, float scale);
extern Image GenImageCellular(int width, int height, int tileSize);
extern Image GenImageText(int width, int height, const char *text);


extern Image ImageCopy(Image image);
extern Image ImageFromImage(Image image, Rectangle rec);
extern Image ImageText(const char *text, int fontSize, Color color);
extern Image ImageTextEx(Font font, const char *text, float fontSize, float spacing, Color tint);
extern void ImageFormat(Image *image, int newFormat);
extern void ImageToPOT(Image *image, Color fill);
extern void ImageCrop(Image *image, Rectangle crop);
extern void ImageAlphaCrop(Image *image, float threshold);
extern void ImageAlphaClear(Image *image, Color color, float threshold);
extern void ImageAlphaMask(Image *image, Image alphaMask);
extern void ImageAlphaPremultiply(Image *image);
extern void ImageBlurGaussian(Image *image, int blurSize);
extern void ImageKernelConvolution(Image *image, float* kernel, int kernelSize);
extern void ImageResize(Image *image, int newWidth, int newHeight);
extern void ImageResizeNN(Image *image, int newWidth,int newHeight);
extern void ImageResizeCanvas(Image *image, int newWidth, int newHeight, int offsetX, int offsetY, Color fill);
extern void ImageMipmaps(Image *image);
extern void ImageDither(Image *image, int rBpp, int gBpp, int bBpp, int aBpp);
extern void ImageFlipVertical(Image *image);
extern void ImageFlipHorizontal(Image *image);
extern void ImageRotate(Image *image, int degrees);
extern void ImageRotateCW(Image *image);
extern void ImageRotateCCW(Image *image);
extern void ImageColorTint(Image *image, Color color);
extern void ImageColorInvert(Image *image);
extern void ImageColorGrayscale(Image *image);
extern void ImageColorContrast(Image *image, float contrast);
extern void ImageColorBrightness(Image *image, int brightness);
extern void ImageColorReplace(Image *image, Color color, Color replace);
extern Color *LoadImageColors(Image image);
extern Color *LoadImagePalette(Image image, int maxPaletteSize, int *colorCount);
extern void UnloadImageColors(Color *colors);
extern void UnloadImagePalette(Color *colors);
extern Rectangle GetImageAlphaBorder(Image image, float threshold);
extern Color GetImageColor(Image image, int x, int y);



extern void ImageClearBackground(Image *dst, Color color);
extern void ImageDrawPixel(Image *dst, int posX, int posY, Color color);
extern void ImageDrawPixelV(Image *dst, Vector2 position, Color color);
extern void ImageDrawLine(Image *dst, int startPosX, int startPosY, int endPosX, int endPosY, Color color);
extern void ImageDrawLineV(Image *dst, Vector2 start, Vector2 end, Color color);
extern void ImageDrawCircle(Image *dst, int centerX, int centerY, int radius, Color color);
extern void ImageDrawCircleV(Image *dst, Vector2 center, int radius, Color color);
extern void ImageDrawCircleLines(Image *dst, int centerX, int centerY, int radius, Color color);
extern void ImageDrawCircleLinesV(Image *dst, Vector2 center, int radius, Color color);
extern void ImageDrawRectangle(Image *dst, int posX, int posY, int width, int height, Color color);
extern void ImageDrawRectangleV(Image *dst, Vector2 position, Vector2 size, Color color);
extern void ImageDrawRectangleRec(Image *dst, Rectangle rec, Color color);
extern void ImageDrawRectangleLines(Image *dst, Rectangle rec, int thick, Color color);
extern void ImageDraw(Image *dst, Image src, Rectangle srcRec, Rectangle dstRec, Color tint);
extern void ImageDrawText(Image *dst, const char *text, int posX, int posY, int fontSize, Color color);
extern void ImageDrawTextEx(Image *dst, Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint);



extern Texture2D LoadTexture(const char *fileName);
extern Texture2D LoadTextureFromImage(Image image);
extern TextureCubemap LoadTextureCubemap(Image image, int layout);
extern RenderTexture2D LoadRenderTexture(int width, int height);
extern 
# 1389 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1389 "src/../include/raylib.sgh"
          IsTextureReady(Texture2D texture);
extern void UnloadTexture(Texture2D texture);
extern 
# 1391 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1391 "src/../include/raylib.sgh"
          IsRenderTextureReady(RenderTexture2D target);
extern void UnloadRenderTexture(RenderTexture2D target);
extern void UpdateTexture(Texture2D texture, const void *pixels);
extern void UpdateTextureRec(Texture2D texture, Rectangle rec, const void *pixels);


extern void GenTextureMipmaps(Texture2D *texture);
extern void SetTextureFilter(Texture2D texture, int filter);
extern void SetTextureWrap(Texture2D texture, int wrap);


extern void DrawTexture(Texture2D texture, int posX, int posY, Color tint);
extern void DrawTextureV(Texture2D texture, Vector2 position, Color tint);
extern void DrawTextureEx(Texture2D texture, Vector2 position, float rotation, float scale, Color tint);
extern void DrawTextureRec(Texture2D texture, Rectangle source, Vector2 position, Color tint);
extern void DrawTexturePro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, float rotation, Color tint);
extern void DrawTextureNPatch(Texture2D texture, NPatchInfo nPatchInfo, Rectangle dest, Vector2 origin, float rotation, Color tint);


extern Color Fade(Color color, float alpha);
extern int ColorToInt(Color color);
extern Vector4 ColorNormalize(Color color);
extern Color ColorFromNormalized(Vector4 normalized);
extern Vector3 ColorToHSV(Color color);
extern Color ColorFromHSV(float hue, float saturation, float value);
extern Color ColorTint(Color color, Color tint);
extern Color ColorBrightness(Color color, float factor);
extern Color ColorContrast(Color color, float contrast);
extern Color ColorAlpha(Color color, float alpha);
extern Color ColorAlphaBlend(Color dst, Color src, Color tint);
extern Color GetColor(unsigned int hexValue);
extern Color GetPixelColor(void *srcPtr, int format);
extern void SetPixelColor(void *dstPtr, Color color, int format);
extern int GetPixelDataSize(int width, int height, int format);






extern Font GetFontDefault(void);
extern Font LoadFont(const char *fileName);
extern Font LoadFontEx(const char *fileName, int fontSize, int *codepoints, int codepointCount);
extern Font LoadFontFromImage(Image image, Color key, int firstChar);
extern Font LoadFontFromMemory(const char *fileType, const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount);
extern 
# 1436 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1436 "src/../include/raylib.sgh"
          IsFontReady(Font font);
extern GlyphInfo *LoadFontData(const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount, int type);
extern Image GenImageFontAtlas(const GlyphInfo *glyphs, Rectangle **glyphRecs, int glyphCount, int fontSize, int padding, int packMethod);
extern void UnloadFontData(GlyphInfo *glyphs, int glyphCount);
extern void UnloadFont(Font font);
extern 
# 1441 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1441 "src/../include/raylib.sgh"
          ExportFontAsCode(Font font, const char *fileName);


extern void DrawFPS(int posX, int posY);
extern void DrawText(const char *text, int posX, int posY, int fontSize, Color color);
extern void DrawTextEx(Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint);
extern void DrawTextPro(Font font, const char *text, Vector2 position, Vector2 origin, float rotation, float fontSize, float spacing, Color tint);
extern void DrawTextCodepoint(Font font, int codepoint, Vector2 position, float fontSize, Color tint);
extern void DrawTextCodepoints(Font font, const int *codepoints, int codepointCount, Vector2 position, float fontSize, float spacing, Color tint);


extern void SetTextLineSpacing(int spacing);
extern int MeasureText(const char *text, int fontSize);
extern Vector2 MeasureTextEx(Font font, const char *text, float fontSize, float spacing);
extern int GetGlyphIndex(Font font, int codepoint);
extern GlyphInfo GetGlyphInfo(Font font, int codepoint);
extern Rectangle GetGlyphAtlasRec(Font font, int codepoint);


extern char *LoadUTF8(const int *codepoints, int length);
extern void UnloadUTF8(char *text);
extern int *LoadCodepoints(const char *text, int *count);
extern void UnloadCodepoints(int *codepoints);
extern int GetCodepointCount(const char *text);
extern int GetCodepoint(const char *text, int *codepointSize);
extern int GetCodepointNext(const char *text, int *codepointSize);
extern int GetCodepointPrevious(const char *text, int *codepointSize);
extern const char *CodepointToUTF8(int codepoint, int *utf8Size);



extern int TextCopy(char *dst, const char *src);
extern 
# 1473 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1473 "src/../include/raylib.sgh"
          TextIsEqual(const char *text1, const char *text2);
extern unsigned int TextLength(const char *text);
extern const char *TextFormat(const char *text, ...);
extern const char *TextSubtext(const char *text, int position, int length);
extern char *TextReplace(const char *text, const char *replace, const char *by);
extern char *TextInsert(const char *text, const char *insert, int position);
extern const char *TextJoin(const char **textList, int count, const char *delimiter);
extern const char **TextSplit(const char *text, char delimiter, int *count);
extern void TextAppend(char *text, const char *append, int *position);
extern int TextFindIndex(const char *text, const char *find);
extern const char *TextToUpper(const char *text);
extern const char *TextToLower(const char *text);
extern const char *TextToPascal(const char *text);
extern int TextToInteger(const char *text);
extern float TextToFloat(const char *text);






extern void DrawLine3D(Vector3 startPos, Vector3 endPos, Color color);
extern void DrawPoint3D(Vector3 position, Color color);
extern void DrawCircle3D(Vector3 center, float radius, Vector3 rotationAxis, float rotationAngle, Color color);
extern void DrawTriangle3D(Vector3 v1, Vector3 v2, Vector3 v3, Color color);
extern void DrawTriangleStrip3D(Vector3 *points, int pointCount, Color color);
extern void DrawCube(Vector3 position, float width, float height, float length, Color color);
extern void DrawCubeV(Vector3 position, Vector3 size, Color color);
extern void DrawCubeWires(Vector3 position, float width, float height, float length, Color color);
extern void DrawCubeWiresV(Vector3 position, Vector3 size, Color color);
extern void DrawSphere(Vector3 centerPos, float radius, Color color);
extern void DrawSphereEx(Vector3 centerPos, float radius, int rings, int slices, Color color);
extern void DrawSphereWires(Vector3 centerPos, float radius, int rings, int slices, Color color);
extern void DrawCylinder(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color);
extern void DrawCylinderEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color);
extern void DrawCylinderWires(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color);
extern void DrawCylinderWiresEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color);
extern void DrawCapsule(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color);
extern void DrawCapsuleWires(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color);
extern void DrawPlane(Vector3 centerPos, Vector2 size, Color color);
extern void DrawRay(Ray ray, Color color);
extern void DrawGrid(int slices, float spacing);






extern Model LoadModel(const char *fileName);
extern Model LoadModelFromMesh(Mesh mesh);
extern 
# 1523 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1523 "src/../include/raylib.sgh"
          IsModelReady(Model model);
extern void UnloadModel(Model model);
extern BoundingBox GetModelBoundingBox(Model model);


extern void DrawModel(Model model, Vector3 position, float scale, Color tint);
extern void DrawModelEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint);
extern void DrawModelWires(Model model, Vector3 position, float scale, Color tint);
extern void DrawModelWiresEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint);
extern void DrawBoundingBox(BoundingBox box, Color color);
extern void DrawBillboard(Camera camera, Texture2D texture, Vector3 position, float size, Color tint);
extern void DrawBillboardRec(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector2 size, Color tint);
extern void DrawBillboardPro(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector3 up, Vector2 size, Vector2 origin, float rotation, Color tint);


extern void UploadMesh(Mesh *mesh, 
# 1538 "src/../include/raylib.sgh" 3 4
                                 _Bool 
# 1538 "src/../include/raylib.sgh"
                                      dynamic);
extern void UpdateMeshBuffer(Mesh mesh, int index, const void *data, int dataSize, int offset);
extern void UnloadMesh(Mesh mesh);
extern void DrawMesh(Mesh mesh, Material material, Matrix transform);
extern void DrawMeshInstanced(Mesh mesh, Material material, const Matrix *transforms, int instances);
extern BoundingBox GetMeshBoundingBox(Mesh mesh);
extern void GenMeshTangents(Mesh *mesh);
extern 
# 1545 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1545 "src/../include/raylib.sgh"
          ExportMesh(Mesh mesh, const char *fileName);
extern 
# 1546 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1546 "src/../include/raylib.sgh"
          ExportMeshAsCode(Mesh mesh, const char *fileName);


extern Mesh GenMeshPoly(int sides, float radius);
extern Mesh GenMeshPlane(float width, float length, int resX, int resZ);
extern Mesh GenMeshCube(float width, float height, float length);
extern Mesh GenMeshSphere(float radius, int rings, int slices);
extern Mesh GenMeshHemiSphere(float radius, int rings, int slices);
extern Mesh GenMeshCylinder(float radius, float height, int slices);
extern Mesh GenMeshCone(float radius, float height, int slices);
extern Mesh GenMeshTorus(float radius, float size, int radSeg, int sides);
extern Mesh GenMeshKnot(float radius, float size, int radSeg, int sides);
extern Mesh GenMeshHeightmap(Image heightmap, Vector3 size);
extern Mesh GenMeshCubicmap(Image cubicmap, Vector3 cubeSize);


extern Material *LoadMaterials(const char *fileName, int *materialCount);
extern Material LoadMaterialDefault(void);
extern 
# 1564 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1564 "src/../include/raylib.sgh"
          IsMaterialReady(Material material);
extern void UnloadMaterial(Material material);
extern void SetMaterialTexture(Material *material, int mapType, Texture2D texture);
extern void SetModelMeshMaterial(Model *model, int meshId, int materialId);


extern ModelAnimation *LoadModelAnimations(const char *fileName, int *animCount);
extern void UpdateModelAnimation(Model model, ModelAnimation anim, int frame);
extern void UnloadModelAnimation(ModelAnimation anim);
extern void UnloadModelAnimations(ModelAnimation *animations, int animCount);
extern 
# 1574 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1574 "src/../include/raylib.sgh"
          IsModelAnimationValid(Model model, ModelAnimation anim);


extern 
# 1577 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1577 "src/../include/raylib.sgh"
          CheckCollisionSpheres(Vector3 center1, float radius1, Vector3 center2, float radius2);
extern 
# 1578 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1578 "src/../include/raylib.sgh"
          CheckCollisionBoxes(BoundingBox box1, BoundingBox box2);
extern 
# 1579 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1579 "src/../include/raylib.sgh"
          CheckCollisionBoxSphere(BoundingBox box, Vector3 center, float radius);
extern RayCollision GetRayCollisionSphere(Ray ray, Vector3 center, float radius);
extern RayCollision GetRayCollisionBox(Ray ray, BoundingBox box);
extern RayCollision GetRayCollisionMesh(Ray ray, Mesh mesh, Matrix transform);
extern RayCollision GetRayCollisionTriangle(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3);
extern RayCollision GetRayCollisionQuad(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4);




typedef void (*AudioCallback)(void *bufferData, unsigned int frames);


extern void InitAudioDevice(void);
extern void CloseAudioDevice(void);
extern 
# 1594 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1594 "src/../include/raylib.sgh"
          IsAudioDeviceReady(void);
extern void SetMasterVolume(float volume);
extern float GetMasterVolume(void);


extern Wave LoadWave(const char *fileName);
extern Wave LoadWaveFromMemory(const char *fileType, const unsigned char *fileData, int dataSize);
extern 
# 1601 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1601 "src/../include/raylib.sgh"
          IsWaveReady(Wave wave);
extern Sound LoadSound(const char *fileName);
extern Sound LoadSoundFromWave(Wave wave);
extern Sound LoadSoundAlias(Sound source);
extern 
# 1605 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1605 "src/../include/raylib.sgh"
          IsSoundReady(Sound sound);
extern void UpdateSound(Sound sound, const void *data, int sampleCount);
extern void UnloadWave(Wave wave);
extern void UnloadSound(Sound sound);
extern void UnloadSoundAlias(Sound alias);
extern 
# 1610 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1610 "src/../include/raylib.sgh"
          ExportWave(Wave wave, const char *fileName);
extern 
# 1611 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1611 "src/../include/raylib.sgh"
          ExportWaveAsCode(Wave wave, const char *fileName);


extern void PlaySound(Sound sound);
extern void StopSound(Sound sound);
extern void PauseSound(Sound sound);
extern void ResumeSound(Sound sound);
extern 
# 1618 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1618 "src/../include/raylib.sgh"
          IsSoundPlaying(Sound sound);
extern void SetSoundVolume(Sound sound, float volume);
extern void SetSoundPitch(Sound sound, float pitch);
extern void SetSoundPan(Sound sound, float pan);
extern Wave WaveCopy(Wave wave);
extern void WaveCrop(Wave *wave, int initSample, int finalSample);
extern void WaveFormat(Wave *wave, int sampleRate, int sampleSize, int channels);
extern float *LoadWaveSamples(Wave wave);
extern void UnloadWaveSamples(float *samples);


extern Music LoadMusicStream(const char *fileName);
extern Music LoadMusicStreamFromMemory(const char *fileType, const unsigned char *data, int dataSize);
extern 
# 1631 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1631 "src/../include/raylib.sgh"
          IsMusicReady(Music music);
extern void UnloadMusicStream(Music music);
extern void PlayMusicStream(Music music);
extern 
# 1634 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1634 "src/../include/raylib.sgh"
          IsMusicStreamPlaying(Music music);
extern void UpdateMusicStream(Music music);
extern void StopMusicStream(Music music);
extern void PauseMusicStream(Music music);
extern void ResumeMusicStream(Music music);
extern void SeekMusicStream(Music music, float position);
extern void SetMusicVolume(Music music, float volume);
extern void SetMusicPitch(Music music, float pitch);
extern void SetMusicPan(Music music, float pan);
extern float GetMusicTimeLength(Music music);
extern float GetMusicTimePlayed(Music music);


extern AudioStream LoadAudioStream(unsigned int sampleRate, unsigned int sampleSize, unsigned int channels);
extern 
# 1648 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1648 "src/../include/raylib.sgh"
          IsAudioStreamReady(AudioStream stream);
extern void UnloadAudioStream(AudioStream stream);
extern void UpdateAudioStream(AudioStream stream, const void *data, int frameCount);
extern 
# 1651 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1651 "src/../include/raylib.sgh"
          IsAudioStreamProcessed(AudioStream stream);
extern void PlayAudioStream(AudioStream stream);
extern void PauseAudioStream(AudioStream stream);
extern void ResumeAudioStream(AudioStream stream);
extern 
# 1655 "src/../include/raylib.sgh" 3 4
     _Bool 
# 1655 "src/../include/raylib.sgh"
          IsAudioStreamPlaying(AudioStream stream);
extern void StopAudioStream(AudioStream stream);
extern void SetAudioStreamVolume(AudioStream stream, float volume);
extern void SetAudioStreamPitch(AudioStream stream, float pitch);
extern void SetAudioStreamPan(AudioStream stream, float pan);
extern void SetAudioStreamBufferSizeDefault(int size);
extern void SetAudioStreamCallback(AudioStream stream, AudioCallback callback);

extern void AttachAudioStreamProcessor(AudioStream stream, AudioCallback processor);
extern void DetachAudioStreamProcessor(AudioStream stream, AudioCallback processor);

extern void AttachAudioMixedProcessor(AudioCallback processor);
extern void DetachAudioMixedProcessor(AudioCallback processor);
# 3 "src/sgccplots.sgc" 2

struct drawer_struct;
typedef struct drawer_struct* drawer;

# 1 "/Users/humzaqureshi/GitHub/sugaryc/include/filter_map_reduce.sgh" 1





__generate(std__filter__T_cond)


__generate(std__map__T_func)


__generate(std__reduce__Tin_func_Tout)

# 8 "src/sgccplots.sgc" 2
# 1 "/Users/humzaqureshi/GitHub/sugaryc/include/assert.sgh" 1
# 9 "src/sgccplots.sgc" 2


# 1 "src/../include/sgccplots.sgh" 1





enum generic_arg_t{
    ARG_COLOR,
    ARG_RADIUS,
    ARG_THICKNESS,
    ARG_STYLE
};

typedef struct{
    enum generic_arg_t t;
    union {
        float f;
        const char* s;
    } data;
} plot_arg;

# 1 "/Users/humzaqureshi/GitHub/sugaryc/include/lists.sgh" 1




# 1 "/Users/humzaqureshi/GitHub/sugaryc/include/assert.sgh" 1
# 6 "/Users/humzaqureshi/GitHub/sugaryc/include/lists.sgh" 2

# 1 "/Users/humzaqureshi/GitHub/sugaryc/include/range.sgh" 1



typedef struct {
    int start;
    int stop;
    int step;
    int cur;
} range_t;

typedef range_t* range_obj;

static inline range_obj __iter__(range_obj r){
    return r;
}

static inline int __start__(range_obj r){
    r->cur = r->start;
    return r->cur;
}

static inline 
# 22 "/Users/humzaqureshi/GitHub/sugaryc/include/range.sgh" 3 4
             _Bool 
# 22 "/Users/humzaqureshi/GitHub/sugaryc/include/range.sgh"
                  __done__(range_obj r){
    return r->cur >= r->stop;
}

static inline int __next__(range_obj r){
    r->cur += r->step;
    return r->cur;
}

static inline range_obj range(int stop){
    range_obj out = (range_obj)GC_malloc(sizeof(range_t));
    out->start = 0;
    out->stop = stop;
    out->step = 1;
    return out;
}
static inline range_obj range(int start, int stop){
    range_obj out = (range_obj)GC_malloc(sizeof(range_t));
    out->start = start;
    out->stop = stop;
    out->step = 1;
    return out;
}
static inline range_obj range(int start, int stop, int step){
    range_obj out = (range_obj)GC_malloc(sizeof(range_t));
    out->start = start;
    out->stop = stop;
    out->step = step;
    return out;
}
# 8 "/Users/humzaqureshi/GitHub/sugaryc/include/lists.sgh" 2







    struct list_struct__template__int{
        int* raw;
        int length;
        int n_allocated;
        int cur;
    };

    typedef struct list_struct__template__int* std__list__template__int;

    static inline std__list__template__int std__make_list__template__int(void){
        std__list__template__int out = (std__list__template__int)GC_malloc(sizeof(struct list_struct__template__int));
        if (!(out != nullptr)){printf("%s: FAILED\n","out != NULL"); exit(1);};
        out->length = 0;
        out->n_allocated = 10;
        out->raw = (int*)GC_malloc(sizeof(int) * 10);
        if (!(out->raw != nullptr)){printf("%s: FAILED\n","out->raw != NULL"); exit(1);};
        return out;
    }

    static inline std__list__template__int __init____template__std__list__template__int(void){
        return std__make_list__template__int();
    }

    static inline void append(std__list__template__int lst, int val){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(lst->length >= 0)){printf("%s: FAILED\n","lst->length >= 0"); exit(1);};
        if (!(lst->length < lst->n_allocated)){
            lst->n_allocated += 10;
            lst->raw = (int*)GC_realloc(lst->raw,sizeof(int) * lst->n_allocated);
            if (!(lst->raw != nullptr)){printf("%s: FAILED\n","lst->raw != NULL"); exit(1);};
        }
        if (!(lst->length < lst->n_allocated)){printf("%s: FAILED\n","lst->length < lst->n_allocated"); exit(1);};
        lst->raw[lst->length] = val;
        lst->length++;
        return;
    }

    static inline void __append__(std__list__template__int lst, int val){
        append(lst,val);
    }

    static inline int pop(std__list__template__int lst, int idx){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(idx < lst->length)){printf("%s: FAILED\n","idx < lst->length"); exit(1);};
        int out = lst->raw[idx];
        for (int i = idx; i < (lst->length-1); i++){
            lst->raw[i] = lst->raw[i+1];
        }
        lst->length--;
        if ((lst->n_allocated - lst->length) > 10){
            lst->n_allocated -= 10;
            if (!(lst->n_allocated > 0)){printf("%s: FAILED\n","lst->n_allocated > 0"); exit(1);};
            if (!(lst->n_allocated >= lst->length)){printf("%s: FAILED\n","lst->n_allocated >= lst->length"); exit(1);};
            lst->raw = (int*)GC_realloc(lst->raw,sizeof(int) * lst->n_allocated);
        }
        return out;
    }

    static inline int pop(std__list__template__int lst){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(lst->length > 0)){printf("%s: FAILED\n","lst->length > 0"); exit(1);};
        return pop(lst,lst->length-1);
    }

    static inline int len(std__list__template__int lst){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        return lst->length;
    }

    static inline void insert(std__list__template__int lst, int idx, int value){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(idx < lst->length)){printf("%s: FAILED\n","idx < lst->length"); exit(1);};
        if (!((lst->length+1) < lst->n_allocated)){
            lst->n_allocated += 10;
            lst->raw = (int*)GC_realloc(lst->raw,sizeof(int) * lst->n_allocated);
            if (!(lst->raw != nullptr)){printf("%s: FAILED\n","lst->raw != NULL"); exit(1);};
        }
        for (int i = lst->length-1; i >= idx; i--){
            lst->raw[i+1] = lst->raw[i];
        }
        lst->raw[idx] = value;
        lst->length++;

    }

    static inline int* __index__(std__list__template__int lst, int* idxs, int n){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(n == 1)){printf("%s: FAILED\n","n == 1"); exit(1);};
        int idx = idxs[0];
        if (!(idx < lst->length)){printf("%s: FAILED\n","idx < lst->length"); exit(1);};
        if (!(lst->raw != nullptr)){printf("%s: FAILED\n","lst->raw != NULL"); exit(1);};
        return &(lst->raw[idx]);
    }

    static inline string __str__(std__list__template__int lst){
        string out = "[";
        for (int i = 0; i < lst->length-1; i++){
            out += to_str(lst->raw[i]) + ", ";
        }
        if (lst->length > 0){
            out += to_str(lst->raw[lst->length-1]);
        }
        out += "]";
        return out;
    }

    static inline std__list__template__int __iter__(std__list__template__int lst){
        return lst;
    }

    static inline int __start__(std__list__template__int lst){
        lst->cur = 0;
        if (lst->length == 0){
            int empty;
            return empty;
        }
        return lst->raw[lst->cur];
    }

    static inline 
# 134 "/Users/humzaqureshi/GitHub/sugaryc/include/lists.sgh" 3 4
                 _Bool 
# 134 "/Users/humzaqureshi/GitHub/sugaryc/include/lists.sgh"
                      __done__(std__list__template__int lst){
        return lst->cur >= lst->length;
    }

    static inline int __next__(std__list__template__int lst){
        lst->cur++;
        return lst->raw[lst->cur];
    }

    static inline void destroy(std__list__template__int lst){
        GC_free(lst->raw);
        GC_free(lst);
    }




    struct list_struct__template__plot_arg{
        plot_arg* raw;
        int length;
        int n_allocated;
        int cur;
    };

    typedef struct list_struct__template__plot_arg* std__list__template__plot_arg;

    static inline std__list__template__plot_arg std__make_list__template__plot_arg(void){
        std__list__template__plot_arg out = (std__list__template__plot_arg)GC_malloc(sizeof(struct list_struct__template__plot_arg));
        if (!(out != nullptr)){printf("%s: FAILED\n","out != NULL"); exit(1);};
        out->length = 0;
        out->n_allocated = 10;
        out->raw = (plot_arg*)GC_malloc(sizeof(plot_arg) * 10);
        if (!(out->raw != nullptr)){printf("%s: FAILED\n","out->raw != NULL"); exit(1);};
        return out;
    }

    static inline std__list__template__plot_arg __init____template__std__list__template__plot_arg(void){
        return std__make_list__template__plot_arg();
    }

    static inline void append(std__list__template__plot_arg lst, plot_arg val){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(lst->length >= 0)){printf("%s: FAILED\n","lst->length >= 0"); exit(1);};
        if (!(lst->length < lst->n_allocated)){
            lst->n_allocated += 10;
            lst->raw = (plot_arg*)GC_realloc(lst->raw,sizeof(plot_arg) * lst->n_allocated);
            if (!(lst->raw != nullptr)){printf("%s: FAILED\n","lst->raw != NULL"); exit(1);};
        }
        if (!(lst->length < lst->n_allocated)){printf("%s: FAILED\n","lst->length < lst->n_allocated"); exit(1);};
        lst->raw[lst->length] = val;
        lst->length++;
        return;
    }

    static inline void __append__(std__list__template__plot_arg lst, plot_arg val){
        append(lst,val);
    }

    static inline plot_arg pop(std__list__template__plot_arg lst, int idx){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(idx < lst->length)){printf("%s: FAILED\n","idx < lst->length"); exit(1);};
        plot_arg out = lst->raw[idx];
        for (int i = idx; i < (lst->length-1); i++){
            lst->raw[i] = lst->raw[i+1];
        }
        lst->length--;
        if ((lst->n_allocated - lst->length) > 10){
            lst->n_allocated -= 10;
            if (!(lst->n_allocated > 0)){printf("%s: FAILED\n","lst->n_allocated > 0"); exit(1);};
            if (!(lst->n_allocated >= lst->length)){printf("%s: FAILED\n","lst->n_allocated >= lst->length"); exit(1);};
            lst->raw = (plot_arg*)GC_realloc(lst->raw,sizeof(plot_arg) * lst->n_allocated);
        }
        return out;
    }

    static inline plot_arg pop(std__list__template__plot_arg lst){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(lst->length > 0)){printf("%s: FAILED\n","lst->length > 0"); exit(1);};
        return pop(lst,lst->length-1);
    }

    static inline int len(std__list__template__plot_arg lst){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        return lst->length;
    }

    static inline void insert(std__list__template__plot_arg lst, int idx, plot_arg value){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(idx < lst->length)){printf("%s: FAILED\n","idx < lst->length"); exit(1);};
        if (!((lst->length+1) < lst->n_allocated)){
            lst->n_allocated += 10;
            lst->raw = (plot_arg*)GC_realloc(lst->raw,sizeof(plot_arg) * lst->n_allocated);
            if (!(lst->raw != nullptr)){printf("%s: FAILED\n","lst->raw != NULL"); exit(1);};
        }
        for (int i = lst->length-1; i >= idx; i--){
            lst->raw[i+1] = lst->raw[i];
        }
        lst->raw[idx] = value;
        lst->length++;

    }

    static inline plot_arg* __index__(std__list__template__plot_arg lst, int* idxs, int n){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(n == 1)){printf("%s: FAILED\n","n == 1"); exit(1);};
        int idx = idxs[0];
        if (!(idx < lst->length)){printf("%s: FAILED\n","idx < lst->length"); exit(1);};
        if (!(lst->raw != nullptr)){printf("%s: FAILED\n","lst->raw != NULL"); exit(1);};
        return &(lst->raw[idx]);
    }

    static inline string __str__(std__list__template__plot_arg lst){
        string out = "[";
        for (int i = 0; i < lst->length-1; i++){
            out += to_str(lst->raw[i]) + ", ";
        }
        if (lst->length > 0){
            out += to_str(lst->raw[lst->length-1]);
        }
        out += "]";
        return out;
    }

    static inline std__list__template__plot_arg __iter__(std__list__template__plot_arg lst){
        return lst;
    }

    static inline plot_arg __start__(std__list__template__plot_arg lst){
        lst->cur = 0;
        if (lst->length == 0){
            plot_arg empty;
            return empty;
        }
        return lst->raw[lst->cur];
    }

    static inline 
# 134 "/Users/humzaqureshi/GitHub/sugaryc/include/lists.sgh" 3 4
                 _Bool 
# 134 "/Users/humzaqureshi/GitHub/sugaryc/include/lists.sgh"
                      __done__(std__list__template__plot_arg lst){
        return lst->cur >= lst->length;
    }

    static inline plot_arg __next__(std__list__template__plot_arg lst){
        lst->cur++;
        return lst->raw[lst->cur];
    }

    static inline void destroy(std__list__template__plot_arg lst){
        GC_free(lst->raw);
        GC_free(lst);
    }




    struct list_struct__template__double{
        double* raw;
        int length;
        int n_allocated;
        int cur;
    };

    typedef struct list_struct__template__double* std__list__template__double;

    static inline std__list__template__double std__make_list__template__double(void){
        std__list__template__double out = (std__list__template__double)GC_malloc(sizeof(struct list_struct__template__double));
        if (!(out != nullptr)){printf("%s: FAILED\n","out != NULL"); exit(1);};
        out->length = 0;
        out->n_allocated = 10;
        out->raw = (double*)GC_malloc(sizeof(double) * 10);
        if (!(out->raw != nullptr)){printf("%s: FAILED\n","out->raw != NULL"); exit(1);};
        return out;
    }

    static inline std__list__template__double __init____template__std__list__template__double(void){
        return std__make_list__template__double();
    }

    static inline void append(std__list__template__double lst, double val){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(lst->length >= 0)){printf("%s: FAILED\n","lst->length >= 0"); exit(1);};
        if (!(lst->length < lst->n_allocated)){
            lst->n_allocated += 10;
            lst->raw = (double*)GC_realloc(lst->raw,sizeof(double) * lst->n_allocated);
            if (!(lst->raw != nullptr)){printf("%s: FAILED\n","lst->raw != NULL"); exit(1);};
        }
        if (!(lst->length < lst->n_allocated)){printf("%s: FAILED\n","lst->length < lst->n_allocated"); exit(1);};
        lst->raw[lst->length] = val;
        lst->length++;
        return;
    }

    static inline void __append__(std__list__template__double lst, double val){
        append(lst,val);
    }

    static inline double pop(std__list__template__double lst, int idx){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(idx < lst->length)){printf("%s: FAILED\n","idx < lst->length"); exit(1);};
        double out = lst->raw[idx];
        for (int i = idx; i < (lst->length-1); i++){
            lst->raw[i] = lst->raw[i+1];
        }
        lst->length--;
        if ((lst->n_allocated - lst->length) > 10){
            lst->n_allocated -= 10;
            if (!(lst->n_allocated > 0)){printf("%s: FAILED\n","lst->n_allocated > 0"); exit(1);};
            if (!(lst->n_allocated >= lst->length)){printf("%s: FAILED\n","lst->n_allocated >= lst->length"); exit(1);};
            lst->raw = (double*)GC_realloc(lst->raw,sizeof(double) * lst->n_allocated);
        }
        return out;
    }

    static inline double pop(std__list__template__double lst){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(lst->length > 0)){printf("%s: FAILED\n","lst->length > 0"); exit(1);};
        return pop(lst,lst->length-1);
    }

    static inline int len(std__list__template__double lst){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        return lst->length;
    }

    static inline void insert(std__list__template__double lst, int idx, double value){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(idx < lst->length)){printf("%s: FAILED\n","idx < lst->length"); exit(1);};
        if (!((lst->length+1) < lst->n_allocated)){
            lst->n_allocated += 10;
            lst->raw = (double*)GC_realloc(lst->raw,sizeof(double) * lst->n_allocated);
            if (!(lst->raw != nullptr)){printf("%s: FAILED\n","lst->raw != NULL"); exit(1);};
        }
        for (int i = lst->length-1; i >= idx; i--){
            lst->raw[i+1] = lst->raw[i];
        }
        lst->raw[idx] = value;
        lst->length++;

    }

    static inline double* __index__(std__list__template__double lst, int* idxs, int n){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(n == 1)){printf("%s: FAILED\n","n == 1"); exit(1);};
        int idx = idxs[0];
        if (!(idx < lst->length)){printf("%s: FAILED\n","idx < lst->length"); exit(1);};
        if (!(lst->raw != nullptr)){printf("%s: FAILED\n","lst->raw != NULL"); exit(1);};
        return &(lst->raw[idx]);
    }

    static inline string __str__(std__list__template__double lst){
        string out = "[";
        for (int i = 0; i < lst->length-1; i++){
            out += to_str(lst->raw[i]) + ", ";
        }
        if (lst->length > 0){
            out += to_str(lst->raw[lst->length-1]);
        }
        out += "]";
        return out;
    }

    static inline std__list__template__double __iter__(std__list__template__double lst){
        return lst;
    }

    static inline double __start__(std__list__template__double lst){
        lst->cur = 0;
        if (lst->length == 0){
            double empty;
            return empty;
        }
        return lst->raw[lst->cur];
    }

    static inline 
# 134 "/Users/humzaqureshi/GitHub/sugaryc/include/lists.sgh" 3 4
                 _Bool 
# 134 "/Users/humzaqureshi/GitHub/sugaryc/include/lists.sgh"
                      __done__(std__list__template__double lst){
        return lst->cur >= lst->length;
    }

    static inline double __next__(std__list__template__double lst){
        lst->cur++;
        return lst->raw[lst->cur];
    }

    static inline void destroy(std__list__template__double lst){
        GC_free(lst->raw);
        GC_free(lst);
    }




    struct list_struct__template__drawer{
        drawer* raw;
        int length;
        int n_allocated;
        int cur;
    };

    typedef struct list_struct__template__drawer* std__list__template__drawer;

    static inline std__list__template__drawer std__make_list__template__drawer(void){
        std__list__template__drawer out = (std__list__template__drawer)GC_malloc(sizeof(struct list_struct__template__drawer));
        if (!(out != nullptr)){printf("%s: FAILED\n","out != NULL"); exit(1);};
        out->length = 0;
        out->n_allocated = 10;
        out->raw = (drawer*)GC_malloc(sizeof(drawer) * 10);
        if (!(out->raw != nullptr)){printf("%s: FAILED\n","out->raw != NULL"); exit(1);};
        return out;
    }

    static inline std__list__template__drawer __init____template__std__list__template__drawer(void){
        return std__make_list__template__drawer();
    }

    static inline void append(std__list__template__drawer lst, drawer val){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(lst->length >= 0)){printf("%s: FAILED\n","lst->length >= 0"); exit(1);};
        if (!(lst->length < lst->n_allocated)){
            lst->n_allocated += 10;
            lst->raw = (drawer*)GC_realloc(lst->raw,sizeof(drawer) * lst->n_allocated);
            if (!(lst->raw != nullptr)){printf("%s: FAILED\n","lst->raw != NULL"); exit(1);};
        }
        if (!(lst->length < lst->n_allocated)){printf("%s: FAILED\n","lst->length < lst->n_allocated"); exit(1);};
        lst->raw[lst->length] = val;
        lst->length++;
        return;
    }

    static inline void __append__(std__list__template__drawer lst, drawer val){
        append(lst,val);
    }

    static inline drawer pop(std__list__template__drawer lst, int idx){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(idx < lst->length)){printf("%s: FAILED\n","idx < lst->length"); exit(1);};
        drawer out = lst->raw[idx];
        for (int i = idx; i < (lst->length-1); i++){
            lst->raw[i] = lst->raw[i+1];
        }
        lst->length--;
        if ((lst->n_allocated - lst->length) > 10){
            lst->n_allocated -= 10;
            if (!(lst->n_allocated > 0)){printf("%s: FAILED\n","lst->n_allocated > 0"); exit(1);};
            if (!(lst->n_allocated >= lst->length)){printf("%s: FAILED\n","lst->n_allocated >= lst->length"); exit(1);};
            lst->raw = (drawer*)GC_realloc(lst->raw,sizeof(drawer) * lst->n_allocated);
        }
        return out;
    }

    static inline drawer pop(std__list__template__drawer lst){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(lst->length > 0)){printf("%s: FAILED\n","lst->length > 0"); exit(1);};
        return pop(lst,lst->length-1);
    }

    static inline int len(std__list__template__drawer lst){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        return lst->length;
    }

    static inline void insert(std__list__template__drawer lst, int idx, drawer value){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(idx < lst->length)){printf("%s: FAILED\n","idx < lst->length"); exit(1);};
        if (!((lst->length+1) < lst->n_allocated)){
            lst->n_allocated += 10;
            lst->raw = (drawer*)GC_realloc(lst->raw,sizeof(drawer) * lst->n_allocated);
            if (!(lst->raw != nullptr)){printf("%s: FAILED\n","lst->raw != NULL"); exit(1);};
        }
        for (int i = lst->length-1; i >= idx; i--){
            lst->raw[i+1] = lst->raw[i];
        }
        lst->raw[idx] = value;
        lst->length++;

    }

    static inline drawer* __index__(std__list__template__drawer lst, int* idxs, int n){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(n == 1)){printf("%s: FAILED\n","n == 1"); exit(1);};
        int idx = idxs[0];
        if (!(idx < lst->length)){printf("%s: FAILED\n","idx < lst->length"); exit(1);};
        if (!(lst->raw != nullptr)){printf("%s: FAILED\n","lst->raw != NULL"); exit(1);};
        return &(lst->raw[idx]);
    }

    static inline string __str__(std__list__template__drawer lst){
        string out = "[";
        for (int i = 0; i < lst->length-1; i++){
            out += to_str(lst->raw[i]) + ", ";
        }
        if (lst->length > 0){
            out += to_str(lst->raw[lst->length-1]);
        }
        out += "]";
        return out;
    }

    static inline std__list__template__drawer __iter__(std__list__template__drawer lst){
        return lst;
    }

    static inline drawer __start__(std__list__template__drawer lst){
        lst->cur = 0;
        if (lst->length == 0){
            drawer empty;
            return empty;
        }
        return lst->raw[lst->cur];
    }

    static inline 
# 134 "/Users/humzaqureshi/GitHub/sugaryc/include/lists.sgh" 3 4
                 _Bool 
# 134 "/Users/humzaqureshi/GitHub/sugaryc/include/lists.sgh"
                      __done__(std__list__template__drawer lst){
        return lst->cur >= lst->length;
    }

    static inline drawer __next__(std__list__template__drawer lst){
        lst->cur++;
        return lst->raw[lst->cur];
    }

    static inline void destroy(std__list__template__drawer lst){
        GC_free(lst->raw);
        GC_free(lst);
    }




    struct list_struct__template__float{
        float* raw;
        int length;
        int n_allocated;
        int cur;
    };

    typedef struct list_struct__template__float* std__list__template__float;

    static inline std__list__template__float std__make_list__template__float(void){
        std__list__template__float out = (std__list__template__float)GC_malloc(sizeof(struct list_struct__template__float));
        if (!(out != nullptr)){printf("%s: FAILED\n","out != NULL"); exit(1);};
        out->length = 0;
        out->n_allocated = 10;
        out->raw = (float*)GC_malloc(sizeof(float) * 10);
        if (!(out->raw != nullptr)){printf("%s: FAILED\n","out->raw != NULL"); exit(1);};
        return out;
    }

    static inline std__list__template__float __init____template__std__list__template__float(void){
        return std__make_list__template__float();
    }

    static inline void append(std__list__template__float lst, float val){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(lst->length >= 0)){printf("%s: FAILED\n","lst->length >= 0"); exit(1);};
        if (!(lst->length < lst->n_allocated)){
            lst->n_allocated += 10;
            lst->raw = (float*)GC_realloc(lst->raw,sizeof(float) * lst->n_allocated);
            if (!(lst->raw != nullptr)){printf("%s: FAILED\n","lst->raw != NULL"); exit(1);};
        }
        if (!(lst->length < lst->n_allocated)){printf("%s: FAILED\n","lst->length < lst->n_allocated"); exit(1);};
        lst->raw[lst->length] = val;
        lst->length++;
        return;
    }

    static inline void __append__(std__list__template__float lst, float val){
        append(lst,val);
    }

    static inline float pop(std__list__template__float lst, int idx){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(idx < lst->length)){printf("%s: FAILED\n","idx < lst->length"); exit(1);};
        float out = lst->raw[idx];
        for (int i = idx; i < (lst->length-1); i++){
            lst->raw[i] = lst->raw[i+1];
        }
        lst->length--;
        if ((lst->n_allocated - lst->length) > 10){
            lst->n_allocated -= 10;
            if (!(lst->n_allocated > 0)){printf("%s: FAILED\n","lst->n_allocated > 0"); exit(1);};
            if (!(lst->n_allocated >= lst->length)){printf("%s: FAILED\n","lst->n_allocated >= lst->length"); exit(1);};
            lst->raw = (float*)GC_realloc(lst->raw,sizeof(float) * lst->n_allocated);
        }
        return out;
    }

    static inline float pop(std__list__template__float lst){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(lst->length > 0)){printf("%s: FAILED\n","lst->length > 0"); exit(1);};
        return pop(lst,lst->length-1);
    }

    static inline int len(std__list__template__float lst){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        return lst->length;
    }

    static inline void insert(std__list__template__float lst, int idx, float value){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(idx < lst->length)){printf("%s: FAILED\n","idx < lst->length"); exit(1);};
        if (!((lst->length+1) < lst->n_allocated)){
            lst->n_allocated += 10;
            lst->raw = (float*)GC_realloc(lst->raw,sizeof(float) * lst->n_allocated);
            if (!(lst->raw != nullptr)){printf("%s: FAILED\n","lst->raw != NULL"); exit(1);};
        }
        for (int i = lst->length-1; i >= idx; i--){
            lst->raw[i+1] = lst->raw[i];
        }
        lst->raw[idx] = value;
        lst->length++;

    }

    static inline float* __index__(std__list__template__float lst, int* idxs, int n){
        if (!(lst != nullptr)){printf("%s: FAILED\n","lst != NULL"); exit(1);};
        if (!(n == 1)){printf("%s: FAILED\n","n == 1"); exit(1);};
        int idx = idxs[0];
        if (!(idx < lst->length)){printf("%s: FAILED\n","idx < lst->length"); exit(1);};
        if (!(lst->raw != nullptr)){printf("%s: FAILED\n","lst->raw != NULL"); exit(1);};
        return &(lst->raw[idx]);
    }

    static inline string __str__(std__list__template__float lst){
        string out = "[";
        for (int i = 0; i < lst->length-1; i++){
            out += to_str(lst->raw[i]) + ", ";
        }
        if (lst->length > 0){
            out += to_str(lst->raw[lst->length-1]);
        }
        out += "]";
        return out;
    }

    static inline std__list__template__float __iter__(std__list__template__float lst){
        return lst;
    }

    static inline float __start__(std__list__template__float lst){
        lst->cur = 0;
        if (lst->length == 0){
            float empty;
            return empty;
        }
        return lst->raw[lst->cur];
    }

    static inline 
# 134 "/Users/humzaqureshi/GitHub/sugaryc/include/lists.sgh" 3 4
                 _Bool 
# 134 "/Users/humzaqureshi/GitHub/sugaryc/include/lists.sgh"
                      __done__(std__list__template__float lst){
        return lst->cur >= lst->length;
    }

    static inline float __next__(std__list__template__float lst){
        lst->cur++;
        return lst->raw[lst->cur];
    }

    static inline void destroy(std__list__template__float lst){
        GC_free(lst->raw);
        GC_free(lst);
    }


__generate(std__list_std__make_list__T)


static inline std__list__template__int to_list(range_obj obj){
    std__list__template__int out = std__make_list__template__int();
    auto __iter_foreach_1 = __iter__(obj); for(auto i = __start__(__iter_foreach_1); !__done__(__iter_foreach_1); i = __next__(__iter_foreach_1)){
        out.append(i);
    }
    return out;
}
# 22 "src/../include/sgccplots.sgh" 2

typedef std__list__template__plot_arg plot_arg_list;

plot_arg_list __add__(plot_arg a, plot_arg b);

plot_arg_list __add__(plot_arg_list a, plot_arg b);

struct plot_struct;
typedef struct plot_struct* plot;

plot make_plot(int screenWidth, int screenHeight, double x_start, double y_start, double x_end, double y_end, double padx, double pady);

void show(plot plt);



    void line(plot plt, std__list__template__int xs, std__list__template__int ys, float thickness, string color);

    void line(plot plt, std__list__template__int xs, std__list__template__int ys, float thickness);

    void line(plot plt, std__list__template__int xs, std__list__template__int ys);

    void line(plot plt, std__list__template__int xs, std__list__template__int ys, plot_arg arg0);

    void line(plot plt, std__list__template__int xs, std__list__template__int ys, plot_arg_list args);

    void scatter(plot plt, std__list__template__int xs, std__list__template__int ys, string style, float radius, string color);

    void scatter(plot plt, std__list__template__int xs, std__list__template__int ys, string style, float radius);

    void scatter(plot plt, std__list__template__int xs, std__list__template__int ys, string style);

    void scatter(plot plt, std__list__template__int xs, std__list__template__int ys);

    void scatter(plot plt, std__list__template__int xs, std__list__template__int ys, plot_arg arg0);

    void scatter(plot plt, std__list__template__int xs, std__list__template__int ys, plot_arg_list args);




    void line(plot plt, std__list__template__double xs, std__list__template__double ys, float thickness, string color);

    void line(plot plt, std__list__template__double xs, std__list__template__double ys, float thickness);

    void line(plot plt, std__list__template__double xs, std__list__template__double ys);

    void line(plot plt, std__list__template__double xs, std__list__template__double ys, plot_arg arg0);

    void line(plot plt, std__list__template__double xs, std__list__template__double ys, plot_arg_list args);

    void scatter(plot plt, std__list__template__double xs, std__list__template__double ys, string style, float radius, string color);

    void scatter(plot plt, std__list__template__double xs, std__list__template__double ys, string style, float radius);

    void scatter(plot plt, std__list__template__double xs, std__list__template__double ys, string style);

    void scatter(plot plt, std__list__template__double xs, std__list__template__double ys);

    void scatter(plot plt, std__list__template__double xs, std__list__template__double ys, plot_arg arg0);

    void scatter(plot plt, std__list__template__double xs, std__list__template__double ys, plot_arg_list args);




plot_arg gColor(string color);

plot_arg gRadius(float radius);

plot_arg gThickness(float thickness);

plot_arg gStyle(string style);

void y_axis(plot plt, float radius, string color);

void x_axis(plot plt, float radius, string color);

void axes(plot plt, float radius, string color);

void y_axis(plot plt, float radius);

void x_axis(plot plt, float radius);

void axes(plot plt, float radius);

void y_axis(plot plt);

void x_axis(plot plt);

void axes(plot plt);
# 12 "src/sgccplots.sgc" 2

string color_cycle[] = {
    "blue",
    "orange",
    "green",
    "purple",
    "skyblue",
    "red",
    "brown"
};

int n_cycle = 7;

struct plot_struct{
    int screenWidth;
    int screenHeight;
    double x_start;
    double y_start;
    double dataWidth;
    double dataHeight;
    std__list__template__drawer drawers;
    int color_cycle;
};

typedef struct plot_struct* plot;

plot make_plot(int screenWidth, int screenHeight, double x_start, double y_start, double x_end, double y_end, double padx, double pady){
    plot out = (plot)GC_malloc(sizeof(struct plot_struct));
    out->screenWidth = screenWidth;
    out->screenHeight = screenHeight;
    out->x_start = (x_start);
    out->y_start = y_start;
    out->dataWidth = (x_end) - x_start;
    out->dataHeight = (y_end) - y_start;
    double pad_width = (out->dataWidth / ((double)out->screenWidth)) * padx;
    double pad_height = (out->dataHeight / ((double)out->screenHeight)) * pady;
    out->x_start -= pad_width;
    out->dataWidth += pad_width*2;
    out->y_start -= pad_height;
    out->dataHeight += pad_height*2;
    out->drawers = std__make_list__template__drawer();
    out->color_cycle = 0;
    return out;
}

static inline float2 world2screen(plot plt, double x, double y){
    return make_float2(((x - plt->x_start)/plt->dataWidth) * (double)plt->screenWidth,(1-((y - plt->y_start)/plt->dataHeight)) * (double)plt->screenHeight);
}

static inline void init_window(plot plt){
    InitWindow(plt->screenWidth,plt->screenHeight,"plot");
    SetTargetFPS(60);
}

static inline void close(plot plt){
    CloseWindow();
}

static inline void draw_point(plot plt, float2 pix, float radius_, Color color, string style){
    float radius = (radius_/(plt->dataWidth)) * (float)(plt->screenWidth);
    Vector2 point;
    point.x = pix.x;
    point.y = pix.y;
    if (style == "o"){
        DrawCircleV(point,radius,color);
        return;
    }
    if (style == "."){
        DrawPixel(point.x,point.y,color);
        return;
    }

}

static inline void draw_points(plot plt, std__list__template__double x, std__list__template__double y, float radius, Color color, string style){
    if (!(len(x) == len(y))){printf("%s: FAILED\n","len(x) == len(y)"); exit(1);};
    for (int i = 0; i < len(x); i++){
        plt.draw_point(plt.world2screen(x[i],y[i]),radius,color,style);
    }
}

static inline void draw_line_segment(plot plt, float2 start_, float2 end_, float thickness_, Color color){
    float thickness = (thickness_/(plt->dataWidth)) * (float)(plt->screenWidth);
    Vector2 start;
    start.x = start_.x;
    start.y = start_.y;
    Vector2 end;
    end.x = end_.x;
    end.y = end_.y;
    DrawLineEx(start,end,thickness,color);
}

static inline void draw_line(plot plt, std__list__template__double x, std__list__template__double y, float thickness, Color color){
    if (!(len(x) == len(y))){printf("%s: FAILED\n","len(x) == len(y)"); exit(1);};
    for (int i = 0; i < len(x)-1; i++){
        plt.draw_line_segment(plt.world2screen(x[i],y[i]),plt.world2screen(x[i+1],y[i+1]),thickness,color);
    }
}

static inline void draw_y_axis(plot plt, float thickness, Color color){
    float2 zero = plt.world2screen(0,0);
    float2 start = make_float2(zero.x,0);
    float2 end = make_float2(zero.x,plt->screenHeight);
    plt.draw_line_segment(start,end,thickness,color);
}

static inline void draw_x_axis(plot plt, float thickness, Color color){
    float2 zero = plt.world2screen(0,0);
    float2 start = make_float2(0,zero.y);
    float2 end = make_float2(plt->screenWidth,zero.y);
    plt.draw_line_segment(start,end,thickness,color);
}

struct line_drawer_struct{
    std__list__template__double xs;
    std__list__template__double ys;
    float thickness;
    Color color;
};

struct scatter_drawer_struct{
    std__list__template__double xs;
    std__list__template__double ys;
    float radius;
    Color color;
    string style;
};

struct x_axis_drawer_struct{
    float thickness;
    Color color;
};

struct y_axis_drawer_struct{
    float thickness;
    Color color;
};

enum drawer_t{
    LINE_DRAWER,
    SCATTER_DRAWER,
    X_AXIS_DRAWER,
    Y_AXIS_DRAWER
};

struct drawer_struct{
    enum drawer_t t;
    union {
        struct line_drawer_struct line_drawer;
        struct scatter_drawer_struct scatter_drawer;
        struct x_axis_drawer_struct x_axis_drawer;
        struct y_axis_drawer_struct y_axis_drawer;
    } drawers;
};

static inline drawer make_line_drawer(std__list__template__double xs, std__list__template__double ys, float thickness, Color color){
    struct line_drawer_struct ldraw;
    ldraw.xs = xs;
    ldraw.ys = ys;
    ldraw.thickness = thickness;
    ldraw.color = color;
    drawer out = (drawer)GC_malloc(sizeof(struct drawer_struct));
    out->t = LINE_DRAWER;
    out->drawers.line_drawer = ldraw;
    return out;
}

static inline drawer make_scatter_drawer(std__list__template__double xs, std__list__template__double ys, float radius, Color color, string style){
    struct scatter_drawer_struct ldraw;
    ldraw.xs = xs;
    ldraw.ys = ys;
    ldraw.radius = radius;
    ldraw.color = color;
    ldraw.style = style;
    drawer out = (drawer)GC_malloc(sizeof(struct drawer_struct));
    out->t = SCATTER_DRAWER;
    out->drawers.scatter_drawer = ldraw;
    return out;
}

static inline drawer make_x_axis_drawer(float thickness, Color color){
    struct x_axis_drawer_struct ldraw;
    ldraw.thickness = thickness;
    ldraw.color = color;
    drawer out = (drawer)GC_malloc(sizeof(struct drawer_struct));
    out->t = X_AXIS_DRAWER;
    out->drawers.x_axis_drawer = ldraw;
    return out;
}

static inline drawer make_y_axis_drawer(float thickness, Color color){
    struct y_axis_drawer_struct ldraw;
    ldraw.thickness = thickness;
    ldraw.color = color;
    drawer out = (drawer)GC_malloc(sizeof(struct drawer_struct));
    out->t = Y_AXIS_DRAWER;
    out->drawers.y_axis_drawer = ldraw;
    return out;
}

static inline void draw_elem(plot plt, drawer d){
    switch (d->t){
        case LINE_DRAWER:
            plt.draw_line(d->drawers.line_drawer.xs,d->drawers.line_drawer.ys,d->drawers.line_drawer.thickness,d->drawers.line_drawer.color);
            break;
        case SCATTER_DRAWER:
            plt.draw_points(d->drawers.scatter_drawer.xs,d->drawers.scatter_drawer.ys,d->drawers.scatter_drawer.radius,d->drawers.scatter_drawer.color,d->drawers.scatter_drawer.style);
            break;
        case X_AXIS_DRAWER:
            plt.draw_x_axis(d->drawers.x_axis_drawer.thickness,d->drawers.x_axis_drawer.color);
            break;
        case Y_AXIS_DRAWER:
            plt.draw_y_axis(d->drawers.y_axis_drawer.thickness,d->drawers.y_axis_drawer.color);
            break;
        default:
            break;
    }
}

static inline void draw_all(plot plt){
    auto __iter_foreach_2 = __iter__(plt->drawers); for(auto i = __start__(__iter_foreach_2); !__done__(__iter_foreach_2); i = __next__(__iter_foreach_2)){
        plt.draw_elem(i);
    }
}

static inline Color string2color(string col){
    if (col == "lightgray")return (Color){ 200, 200, 200, 255 };
    if (col == "gray")return (Color){ 130, 130, 130, 255 };
    if (col == "darkgray")return (Color){ 80, 80, 80, 255 };
    if (col == "blue")return (Color){ 0, 121, 241, 255 };
    if (col == "red")return (Color){ 230, 41, 55, 255 };
    if (col == "orange")return (Color){ 255, 161, 0, 255 };
    if (col == "green")return (Color){ 0, 228, 48, 255 };
    if (col == "purple")return (Color){ 200, 122, 255, 255 };
    if (col == "skyblue")return (Color){ 102, 191, 255, 255 };
    if (col == "brown")return (Color){ 127, 106, 79, 255 };
    if (col == "black")return (Color){ 0, 0, 0, 255 };
    return (Color){ 0, 0, 0, 255 };
}

void line(plot plt, std__list__template__double xs, std__list__template__double ys, float thickness, string color){
    println(color);
    plt->drawers.append(make_line_drawer(xs,ys,thickness,string2color(color)));
}

void scatter(plot plt, std__list__template__double xs, std__list__template__double ys, string style, float radius, string color){
    println(color);
    plt->drawers.append(make_scatter_drawer(xs,ys,radius,string2color(color),style));
}

void y_axis(plot plt, float radius, string color){
    plt->drawers.append(make_y_axis_drawer(radius,string2color(color)));
}

void x_axis(plot plt, float radius, string color){
    plt->drawers.append(make_x_axis_drawer(radius,string2color(color)));
}

void y_axis(plot plt, float radius){
    plt.y_axis(radius,"black");
}

void x_axis(plot plt, float radius){
    plt.x_axis(radius,"black");
}

void y_axis(plot plt){
    plt.y_axis(0.5,"black");
}

void x_axis(plot plt){
    plt.x_axis(0.5,"black");
}

void axes(plot plt, float radius, string color){
    plt.y_axis(radius,color);
    plt.x_axis(radius,color);
}

void axes(plot plt, float radius){
    plt.axes(radius,"black");
}

void axes(plot plt){
    plt.axes(0.5,"black");
}



    std__list__template__double to_double_list(std__list__template__float lst){
        auto out = std__make_list__template__double();
        for (int i = 0; i < len(lst); i++){
            out.append(lst[i]);
        }
        return out;
    }

    void line(plot plt, std__list__template__float xs, std__list__template__float ys, float thickness, string color){
        line(plt,xs.to_double_list(),ys.to_double_list(),thickness,color);
    }

    void scatter(plot plt, std__list__template__float xs, std__list__template__float ys, string style, float radius, string color){
        scatter(plt,xs.to_double_list(),ys.to_double_list(),style,radius,color);
    }



    std__list__template__double to_double_list(std__list__template__int lst){
        auto out = std__make_list__template__double();
        for (int i = 0; i < len(lst); i++){
            out.append(lst[i]);
        }
        return out;
    }

    void line(plot plt, std__list__template__int xs, std__list__template__int ys, float thickness, string color){
        line(plt,xs.to_double_list(),ys.to_double_list(),thickness,color);
    }

    void scatter(plot plt, std__list__template__int xs, std__list__template__int ys, string style, float radius, string color){
        scatter(plt,xs.to_double_list(),ys.to_double_list(),style,radius,color);
    }



plot_arg gColor(string color){
    plot_arg out;
    out.t = ARG_COLOR;
    out.data.s = color;
    return out;
}

plot_arg gRadius(float radius){
    plot_arg out;
    out.t = ARG_RADIUS;
    out.data.f = radius;
    return out;
}

plot_arg gThickness(float thickness){
    plot_arg out;
    out.t = ARG_THICKNESS;
    out.data.f = thickness;
    return out;
}

plot_arg gStyle(string style){
    plot_arg out;
    out.t = ARG_STYLE;
    out.data.s = style;
    return out;
}

plot_arg_list __add__(plot_arg a, plot_arg b){
    plot_arg_list out = std__make_list__template__plot_arg();
    out.append(a);
    out.append(b);
    return out;
}

plot_arg_list __add__(plot_arg_list a, plot_arg b){
    a.append(b);
    return a;
}



    void line(plot plt, std__list__template__double xs, std__list__template__double ys, float thickness){
        line(plt,xs,ys,thickness,color_cycle[(plt->color_cycle) % n_cycle]);
        plt->color_cycle++;
    }

    void line(plot plt, std__list__template__double xs, std__list__template__double ys){
        line(plt,xs,ys,1);
    }

    void line(plot plt, std__list__template__double xs, std__list__template__double ys, plot_arg arg0){
        float thickness = 1;
        string color = color_cycle[(plt->color_cycle) % n_cycle];
        switch (arg0.t){
            case ARG_THICKNESS:
                thickness = arg0.data.f;
                break;
            case ARG_COLOR:
                color = arg0.data.s;
                break;
            default:
                break;
        }
        line(plt,xs,ys,thickness,color);
    }

    void line(plot plt, std__list__template__double xs, std__list__template__double ys, plot_arg_list args){
        float thickness = 1;
        string color = color_cycle[(plt->color_cycle) % n_cycle];
        auto __iter_foreach_3 = __iter__(args); for(auto arg0 = __start__(__iter_foreach_3); !__done__(__iter_foreach_3); arg0 = __next__(__iter_foreach_3)){
            switch (arg0.t){
                case ARG_THICKNESS:
                    thickness = arg0.data.f;
                    break;
                case ARG_COLOR:
                    color = arg0.data.s;
                    break;
                default:
                    break;
            }
        }
        line(plt,xs,ys,thickness,color);
    }

    void scatter(plot plt, std__list__template__double xs, std__list__template__double ys, string style, float radius){
        scatter(plt,xs,ys,style,radius,color_cycle[(plt->color_cycle) % n_cycle]);
        plt->color_cycle++;
    }

    void scatter(plot plt, std__list__template__double xs, std__list__template__double ys, string style){
        scatter(plt,xs,ys,style,1);
    }

    void scatter(plot plt, std__list__template__double xs, std__list__template__double ys){
        scatter(plt,xs,ys,"o");
    }

    void scatter(plot plt, std__list__template__double xs, std__list__template__double ys, plot_arg arg0){
        float radius = 1;
        string color = color_cycle[(plt->color_cycle) % n_cycle];
        string style = "o";
        switch (arg0.t){
            case ARG_STYLE:
                style = arg0.data.s;
                break;
            case ARG_RADIUS:
                radius = arg0.data.f;
                break;
            case ARG_COLOR:
                color = arg0.data.s;
                break;
            default:
                break;
        }
        scatter(plt,xs,ys,style,radius,color);
    }

    void scatter(plot plt, std__list__template__double xs, std__list__template__double ys, plot_arg_list args){
        float radius = 1;
        string color = color_cycle[(plt->color_cycle) % n_cycle];
        string style = "o";
        auto __iter_foreach_4 = __iter__(args); for(auto arg0 = __start__(__iter_foreach_4); !__done__(__iter_foreach_4); arg0 = __next__(__iter_foreach_4)){
            switch (arg0.t){
                case ARG_STYLE:
                    style = arg0.data.s;
                    break;
                case ARG_RADIUS:
                    radius = arg0.data.f;
                    break;
                case ARG_COLOR:
                    color = arg0.data.s;
                    break;
                default:
                    break;
            }
        }
        scatter(plt,xs,ys,style,radius,color);
    }




    void line(plot plt, std__list__template__float xs, std__list__template__float ys, float thickness){
        line(plt,xs,ys,thickness,color_cycle[(plt->color_cycle) % n_cycle]);
        plt->color_cycle++;
    }

    void line(plot plt, std__list__template__float xs, std__list__template__float ys){
        line(plt,xs,ys,1);
    }

    void line(plot plt, std__list__template__float xs, std__list__template__float ys, plot_arg arg0){
        float thickness = 1;
        string color = color_cycle[(plt->color_cycle) % n_cycle];
        switch (arg0.t){
            case ARG_THICKNESS:
                thickness = arg0.data.f;
                break;
            case ARG_COLOR:
                color = arg0.data.s;
                break;
            default:
                break;
        }
        line(plt,xs,ys,thickness,color);
    }

    void line(plot plt, std__list__template__float xs, std__list__template__float ys, plot_arg_list args){
        float thickness = 1;
        string color = color_cycle[(plt->color_cycle) % n_cycle];
        auto __iter_foreach_5 = __iter__(args); for(auto arg0 = __start__(__iter_foreach_5); !__done__(__iter_foreach_5); arg0 = __next__(__iter_foreach_5)){
            switch (arg0.t){
                case ARG_THICKNESS:
                    thickness = arg0.data.f;
                    break;
                case ARG_COLOR:
                    color = arg0.data.s;
                    break;
                default:
                    break;
            }
        }
        line(plt,xs,ys,thickness,color);
    }

    void scatter(plot plt, std__list__template__float xs, std__list__template__float ys, string style, float radius){
        scatter(plt,xs,ys,style,radius,color_cycle[(plt->color_cycle) % n_cycle]);
        plt->color_cycle++;
    }

    void scatter(plot plt, std__list__template__float xs, std__list__template__float ys, string style){
        scatter(plt,xs,ys,style,1);
    }

    void scatter(plot plt, std__list__template__float xs, std__list__template__float ys){
        scatter(plt,xs,ys,"o");
    }

    void scatter(plot plt, std__list__template__float xs, std__list__template__float ys, plot_arg arg0){
        float radius = 1;
        string color = color_cycle[(plt->color_cycle) % n_cycle];
        string style = "o";
        switch (arg0.t){
            case ARG_STYLE:
                style = arg0.data.s;
                break;
            case ARG_RADIUS:
                radius = arg0.data.f;
                break;
            case ARG_COLOR:
                color = arg0.data.s;
                break;
            default:
                break;
        }
        scatter(plt,xs,ys,style,radius,color);
    }

    void scatter(plot plt, std__list__template__float xs, std__list__template__float ys, plot_arg_list args){
        float radius = 1;
        string color = color_cycle[(plt->color_cycle) % n_cycle];
        string style = "o";
        auto __iter_foreach_6 = __iter__(args); for(auto arg0 = __start__(__iter_foreach_6); !__done__(__iter_foreach_6); arg0 = __next__(__iter_foreach_6)){
            switch (arg0.t){
                case ARG_STYLE:
                    style = arg0.data.s;
                    break;
                case ARG_RADIUS:
                    radius = arg0.data.f;
                    break;
                case ARG_COLOR:
                    color = arg0.data.s;
                    break;
                default:
                    break;
            }
        }
        scatter(plt,xs,ys,style,radius,color);
    }




    void line(plot plt, std__list__template__int xs, std__list__template__int ys, float thickness){
        line(plt,xs,ys,thickness,color_cycle[(plt->color_cycle) % n_cycle]);
        plt->color_cycle++;
    }

    void line(plot plt, std__list__template__int xs, std__list__template__int ys){
        line(plt,xs,ys,1);
    }

    void line(plot plt, std__list__template__int xs, std__list__template__int ys, plot_arg arg0){
        float thickness = 1;
        string color = color_cycle[(plt->color_cycle) % n_cycle];
        switch (arg0.t){
            case ARG_THICKNESS:
                thickness = arg0.data.f;
                break;
            case ARG_COLOR:
                color = arg0.data.s;
                break;
            default:
                break;
        }
        line(plt,xs,ys,thickness,color);
    }

    void line(plot plt, std__list__template__int xs, std__list__template__int ys, plot_arg_list args){
        float thickness = 1;
        string color = color_cycle[(plt->color_cycle) % n_cycle];
        auto __iter_foreach_7 = __iter__(args); for(auto arg0 = __start__(__iter_foreach_7); !__done__(__iter_foreach_7); arg0 = __next__(__iter_foreach_7)){
            switch (arg0.t){
                case ARG_THICKNESS:
                    thickness = arg0.data.f;
                    break;
                case ARG_COLOR:
                    color = arg0.data.s;
                    break;
                default:
                    break;
            }
        }
        line(plt,xs,ys,thickness,color);
    }

    void scatter(plot plt, std__list__template__int xs, std__list__template__int ys, string style, float radius){
        scatter(plt,xs,ys,style,radius,color_cycle[(plt->color_cycle) % n_cycle]);
        plt->color_cycle++;
    }

    void scatter(plot plt, std__list__template__int xs, std__list__template__int ys, string style){
        scatter(plt,xs,ys,style,1);
    }

    void scatter(plot plt, std__list__template__int xs, std__list__template__int ys){
        scatter(plt,xs,ys,"o");
    }

    void scatter(plot plt, std__list__template__int xs, std__list__template__int ys, plot_arg arg0){
        float radius = 1;
        string color = color_cycle[(plt->color_cycle) % n_cycle];
        string style = "o";
        switch (arg0.t){
            case ARG_STYLE:
                style = arg0.data.s;
                break;
            case ARG_RADIUS:
                radius = arg0.data.f;
                break;
            case ARG_COLOR:
                color = arg0.data.s;
                break;
            default:
                break;
        }
        scatter(plt,xs,ys,style,radius,color);
    }

    void scatter(plot plt, std__list__template__int xs, std__list__template__int ys, plot_arg_list args){
        float radius = 1;
        string color = color_cycle[(plt->color_cycle) % n_cycle];
        string style = "o";
        auto __iter_foreach_8 = __iter__(args); for(auto arg0 = __start__(__iter_foreach_8); !__done__(__iter_foreach_8); arg0 = __next__(__iter_foreach_8)){
            switch (arg0.t){
                case ARG_STYLE:
                    style = arg0.data.s;
                    break;
                case ARG_RADIUS:
                    radius = arg0.data.f;
                    break;
                case ARG_COLOR:
                    color = arg0.data.s;
                    break;
                default:
                    break;
            }
        }
        scatter(plt,xs,ys,style,radius,color);
    }




void show(plot plt){
    plt.init_window();

    while (!WindowShouldClose())
    {
        BeginDrawing();

        ClearBackground((Color){ 245, 245, 245, 255 });

        plt.draw_all();

        EndDrawing();
    }

    plt.close();
}
